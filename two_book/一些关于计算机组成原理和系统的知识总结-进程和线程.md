# 一些关于计算机组成原理和系统的知识总结-进程和线程

标签（空格分隔）： 未分类

---

####一些疑问

1.进程和线程。
进程是资源分配的基本单位，一个进程可能有多个线程，线程是调度的基本单位。我们知道进程和线程一样，都有3种状态。就绪，运行，阻塞。

0）先说一下用户空间，和内核空间。在操作系统中的代码实现，就是内核空间，内核代码起始地址都是0X30000000，用户空间是0X3000 0000以下。所以，运行0X3000 0000以上的代码就是运行在内核空间，内核态，下面的呢就是用户态。从用户地址空间切换到内核地址空间是需要中断才能切换的。PS：两个进程之间地址空间不同，其也要切换的。

1）POSIX线程：可移植的线程，Pthread。对于线程的实现的有三种：
一种就是放在用户空间，内核根本不知道，内核还是按照单线程进程管理，这样就可以通过函数库去实现了，大多数都是这么做的，即使内核不支持。好处是切换快速，坏处也不少。
相当于在进程中实现了一个CPU。
一种是在内核实现线程，把线程包放在内核中，不过开销比较大。
还有一种是混合式的，这样的话用户线程多路复用进程。

2.进程通信IPC问题。
比如shell管道中，一个输出当作第二个输入。一个进程把数据输入打印机，一个进程从打印机拿出数据来。对于共享内存区，这时候应该怎么办。
1）现在提供几种互斥方案。
1.中断屏蔽对于单核是可以的，多核只有一个中断屏蔽了没有用。
2.锁变量，这个不行，因为读，改，这两个操作可能交叉。
3.严格轮换法，其实就是自旋锁
4.Peterson解法
5.TSL指令，硬件支持方案。TSL RX，LOCK
即是测试并加锁（TEST AND SET），这个会锁住内存总线的。不过，现在都使用XCHG,来交换了。
总结一下：Peterson揭发和XCHG都是忙等待的。

2）进程之间的通信原语(sleep和wakeup)
***这个是通信原语：不可分割的。***
这个在无法进入临界区是阻塞，而不是忙等。最简单的是：
sleep:系统调用，引起进程阻塞。
wakeup：系统调用，唤醒某一个进程。
用这个作为例子来解决只有一个生产者和一个消费者的问题，但是有一个问题，对于count的变量没有互斥。

3）信号量问题
down和up，这两个都是原子操作，不可分割，用它们来解决生产者和消费者。为了确保信号量能偶解决问题，最终要的是确保他们不可分割，所以采用XCHG来确保每个信号量。
对于信号量的实现：需要保证不可分割的方式来实现，保证互斥，屏蔽所有中断。
P：的操作语义如下
```
x = x-1
if (x<0) sleep
```
为了保证P原子性，关闭所有的中断。
1.同步问题-生产者和消费者
```
P(EMPTY)
P(MUTEX)
...
V(MUTEX)
V(FULL)
```
```
P(FULL)
P(MUTEX)
...
V(MUTEXT)
V(EMPTY)
```
2.互斥问题
其实，就是Xchg，不过会阻塞，其实，因为时间片用完，也会触发时钟中断。

总结：1）对于不同的进程，虽然地址空间不同，但信号量是必须共享的地址空间，所以可以放在内核的数据结构中。

3.管程
信号量很容易因为操作不当，为了避免死锁，提出了一种高级的同步原语，称为管程（monitor)。管程是由过程和变量等数据结构组成的。
wait和signal。
1）JAVA语言就是支持管程的。
2）但是JAVA支持的同步方法和其他经典管程有着本质的区别。它有两个方法：
wait和notify，分别对应sleep和wakeup。

管程是一个语言成分。

4.消息传递
send和receive是系统调用。

5.屏障

4）线程调度
线程调度得区分是用户级的线程还是内核级的线程。
1.如果是用户级的线程，时间片没有用完之前，A线程可以一直使用运行，除非运行结束，这个时候线程调度程序可以选择另一个线程继续运行。缺点：没有时钟将一个运行过长的来中断点。
而且，一旦用户级别的线程阻塞，整个进程都会被挂起。
2.内核线程切换代价比较大，修改内存映像，清楚高速缓存。

5）经典的IPC问题
1.哲学家就餐问题
有一种会发生饥俄的算法：
就是先拿到左边，如果右边拿不到，就放下左边，过一会儿重复，这个数字是随机的,不然的话，可能一直都是一样的。

2.读者写者问题
读者写者问题：
分为读者优先：就是有读者在里面时，同时有写者在等待，读者允许进入
写者优先：就是有读者在里面时，同时有写者在等，读者会被挂起


###锁

1.自旋锁：就是请求不到的话，会原地不停地查看，并不会阻塞线程，这也是跟互斥锁的最大区别了，自旋锁适用于锁起来非常短的时间。
互斥锁是请求不到，就自动放弃，阻塞线程。他可以用自旋锁来实现，自旋了一段时间或者次数以后，如果得不到，就自动放弃，阻塞线程。

关于自旋锁，单CPU的时候，根本用不着自旋锁，直接swqp和test_and_set这些原子指令就可以完成了，因为中断是发生在指令完成以后。
自旋锁适用于SMP，多处理器的情况下，是用锁总线的方法来做的。
自旋锁算法
```
do{
b=1;
while(b){
lock(bus);
b = test_and_set(&lock);
unlock(bus);
}
```
具体实现(spin_lock和spin_unlock)
```  
while(xchg(&lk->locked, 1) != 0) ;

xchg(&lk->locked, 0);
```
使用时，这样做。
```
spin_lock(lock)
//do something()
spin_ublock()
```


2.读写锁。

3.哲学家问题


---------------------------------------------------------
1.Linux中的线程模型并不是经典的线程模型。
Linux中是有内核线程的，不过它的内核线程比较特殊，是只能运行在内核态的，也就是说只能运行在内核地址空间，Linux中用内核线程做一些很重要的事情，经常是守护线程之类的，比如cron。
我们经常做Linux下的并发开发，是实现的用户态线程，有一个标准叫做POSIX线程。
1）create
exit
join
yield
init 和 destroy
2)用户级线程要发生阻塞时，可以通过进程的线程调度程序发生过程调用来切换完成。
但是，发生需要系统调用的阻塞时，整个进程就都会被阻塞了。
3）用户线程和内核线程混合起来复用。

2.管程是一种数据机构，是语言机制的。

3.信号量的实现机制：保证原子性，屏蔽所有中断。
```
P(count):

spin_lock(mutext)
x = x - 1
if (x < 0) { spin_unlock(mutext); sleep() ; // go to first }
spin_unlock(mutext)
```

------------------------------------------------------------------
###Java并发基础知识
1.在Java中线程状态切换方法也有类似POSXI这几种：
1）create是生成类就会生成
2）start方法是线程开始就绪，等待运行。
3）join是等待其它线程结束
4）yield是放弃线程运行时间
5）setProity是设置优先级的方法，一共10级
6）sleep方法是沉睡
7）interrupt方法，中断线程。被中断后，要发出中断异常，关于中断异常，不仅，interrupt，Join和sleep也会发出。这里中断相当于是一个状态，还有一个检测方法是否是中断状态，interrupted().调用中断方法一般是发生死锁，强行恢复。

PS：sleep和yield并不会释放锁。
PS：还有两个方法wait和notify这是继承自Object

2.同步方法
1)synchronized是内置锁

3.wait和notofy方法只有类支持多线程时才有用，
1）notify只是随机选择一个阻塞变为可执行，notifyall是选择所有
2）wati将会释放锁
