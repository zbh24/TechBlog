<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>frag</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library frag</h1>

<code>
<span class="keyword">Load</span> seplog_header.<br/>

<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> Omega.<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> Bool.<br/>

<br/>
<span class="keyword">Definition</span> <a name="Pi"></a>Pi := expr_b.<br/>

<br/>
<span class="keyword">Inductive</span> <a name="Sigma"></a>Sigma : <span class="keyword">Set</span> :=<br/>
&nbsp;&nbsp;<a name="singl"></a>singl : expr -&gt; expr -&gt; Sigma<br/>
&nbsp;&nbsp;| <a name="cell"></a>cell : expr -&gt; Sigma<br/>
&nbsp;&nbsp;| <a name="epsi"></a>epsi : Sigma<br/>
&nbsp;&nbsp;| <a name="star"></a>star : Sigma -&gt; Sigma -&gt; Sigma.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="Sigma_interp"></a>Sigma_interp (a : Sigma) : assert :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> a <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="singl"></a>singl e1 e2 =&gt; e1 |-&gt; e2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| epsi =&gt; sep.emp<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| star s1 s2 =&gt; (Sigma_interp s1) ** (Sigma_interp s2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| cell e =&gt; (<span class="keyword">fun</span> s h =&gt; exists v, (e |-&gt; int_e v) s h)<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Definition</span> <a name="assrt"></a>assrt := prod Pi Sigma.<br/>

<br/>
<span class="keyword">Definition</span> <a name="assrt_interp"></a>assrt_interp (a: assrt) : assert :=<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> a <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pi, sigm) =&gt; (<span class="keyword">fun</span> s h =&gt; eval_b pi s = true /\ Sigma_interp sigm s h)<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Inductive</span> <a name="ps1"></a>ps1 : assrt -&gt; assrt -&gt; <span class="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<a name="ps1_incons"></a>ps1_incons: forall pi1 pi2 sig1 sig2, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall s , eval_b pi1 s = true -&gt; False) -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,sig1) (pi2,sig2)<br/>
<br/>
&nbsp;&nbsp;| <a name="ps1_tauto"></a>ps1_tauto: forall pi1 pi2, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall s , eval_b pi1 s = true -&gt; eval_b pi2 s = true) -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,epsi) (pi2,epsi)<br/>
<br/>
&nbsp;&nbsp;| <a name="ps1_coml"></a>ps1_coml: forall pi1 sig1 sig2 L,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,star sig2 sig1) L -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,star sig1 sig2) L<br/>
<br/>
&nbsp;&nbsp;| <a name="ps1_comr"></a>ps1_comr: forall pi1 sig1 sig2 L,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 L (pi1,star sig2 sig1)  -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 L (pi1,star sig1 sig2)<br/>
<br/>
&nbsp;&nbsp;| <a name="ps1_assocl"></a>ps1_assocl: forall pi1 sig1 sig2 sig3 L,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,star (star sig1 sig2) sig3) L -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,star sig1 (star sig2 sig3)) L<br/>
<br/>
&nbsp;&nbsp;| <a name="ps1_assocr"></a>ps1_assocr: forall pi1 sig1 sig2 sig3 L,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 L (pi1,star (star sig1 sig2) sig3)  -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 L (pi1,star sig1 (star sig2 sig3))<br/>
<br/>
&nbsp;&nbsp;| <a name="ps1_epseliml"></a>ps1_epseliml: forall pi1 sig1 L,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,sig1) L -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,star sig1 epsi) L<br/>
<br/>
&nbsp;&nbsp;| <a name="ps1_epselimr"></a>ps1_epselimr: forall pi1 sig1 L,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1  L (pi1,sig1) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1  L (pi1,star sig1 epsi)<br/>
<br/>
&nbsp;&nbsp;| <a name="ps1_epsintrol"></a>ps1_epsintrol: forall pi1 sig1 L,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,star sig1 epsi) L -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,sig1) L<br/>
<br/>
&nbsp;&nbsp;| <a name="ps1_epsintror"></a>ps1_epsintror: forall pi1 sig1 L,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1  L (pi1,star sig1 epsi) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1  L (pi1,sig1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;| <a name="ps1_star_elim"></a>ps1_star_elim: forall pi1 pi2 sig1 sig2 e1 e2 e3 e4,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall s, eval_b pi1 s = true -&gt; eval_b (e1 == e3) s = true) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall s , eval_b pi1 s = true -&gt; eval_b (e2 == e4) s = true) -&gt;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,sig1) (pi2,sig2) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,star sig1 (singl e1 e2)) (pi2, star sig2 (singl e3 e4))<br/>
<br/>
&nbsp;&nbsp;| <a name="ps1_star_elim'"></a>ps1_star_elim': forall pi1 pi2 sig1 sig2 e1 e2 e3,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall s, eval_b pi1 s = true -&gt; eval_b (e1 == e3) s = true) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,sig1) (pi2,sig2) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,star sig1 (singl e1 e2)) (pi2, star sig2 (cell e3))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;| <a name="ps1_star_elim''"></a>ps1_star_elim'': forall pi1 pi2 sig1 sig2 e1 e3,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall s, eval_b pi1 s = true -&gt; eval_b (e1 == e3) s = true) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,sig1) (pi2,sig2) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps1 (pi1,star sig1 (cell e1)) (pi2, star sig2 (cell e3)).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="ps1_soundness"></a>ps1_soundness: forall P Q, ps1 P Q -&gt; <br/>
&nbsp;&nbsp;(assrt_interp P) ==&gt; (assrt_interp Q).<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>
<span class="keyword">Ltac</span> ps1_turnl :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> goal <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 (?Pi, cell ?e) ?L =&gt; eapply ps1_epsintrol; eapply ps1_coml; repeat eapply ps1_assocl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 (?Pi, singl ?e1 ?e2) ?L =&gt; eapply ps1_epsintrol; eapply ps1_coml; repeat eapply ps1_assocl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 (?Pi, star ?e1 ?e2) ?L =&gt; eapply ps1_coml; repeat eapply ps1_assocl<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Ltac</span> ps1_turnr :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> goal <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 ?L (?Pi, cell ?e) =&gt; eapply ps1_epsintror; eapply ps1_comr; repeat eapply ps1_assocr<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 ?L (?Pi, singl ?e1 ?e2) =&gt; eapply ps1_epsintror; eapply ps1_comr; repeat eapply ps1_assocr<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 ?L (?Pi, star ?e1 ?e2) =&gt; eapply ps1_comr; repeat eapply ps1_assocr<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Ltac</span> ps1_resolve := repeat eapply ps1_assocr; repeat eapply ps1_assocl;<br/>
&nbsp;&nbsp;<span class="keyword">match</span> goal <span class="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 (?pi1, star ?sig1 epsi) ?L =&gt; ps1_turnl; idtac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 ?L (?Pi, cell ?e) =&gt; ps1_turnr; idtac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 ?L (?Pi, singl ?e1 ?e2) =&gt; ps1_turnr; idtac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 (?Pi, cell ?e) ?L =&gt; ps1_turnl; idtac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 (?Pi, singl ?e1 ?e2) ?L =&gt; ps1_turnl; idtac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 (?pi1, epsi) (?pi2, epsi) =&gt; eapply ps1_tauto; [intros; Omega_exprb]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 (?pi1, epsi) (?pi2, epsi) =&gt; eapply ps1_incons; [intros; Omega_exprb]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;(*****)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 (?pi1, star ?e epsi) ?L =&gt; eapply ps1_epseliml; idtac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 ?L (?pi2, star ?e epsi) =&gt; eapply ps1_epselimr; idtac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;(*****)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 (?pi1, star ?sig1 (singl ?e1 ?e2)) (?pi2, star ?sig2 (singl ?e3 ?e4)) =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eapply ps1_star_elim; [ Omega_exprb | Omega_exprb | idtac] || ps1_turnl; idtac)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 (?pi1, star ?sig1 (singl ?e1 ?e2)) (?pi2, star ?sig2 (cell ?e3)) =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eapply ps1_star_elim'; [ Omega_exprb | idtac] || ps1_turnl; idtac)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 (?pi1, star ?sig1 (cell ?e1)) (?pi2, star ?sig2 (cell ?e3)) =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eapply ps1_star_elim''; [ Omega_exprb | idtac] || ps1_turnl; idtac)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- ps1 (?pi2, star ?sig2 (cell ?e3)) (?pi1, star ?sig1 (singl ?e1 ?e2)) =&gt; ps1_turnl<br/>
<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Ltac</span> ps1_Resolve := repeat ps1_resolve.<br/>

<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> <a class="modref" href="expr_b_dp.html">expr_b_dp</a>.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="Sigma_clean_epsi"></a>Sigma_clean_epsi (t: Sigma) : Sigma :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> t <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| star t1 t2 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> (Sigma_clean_epsi t1) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| epsi =&gt; (Sigma_clean_epsi t2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| t1' =&gt; <span class="keyword">match</span> (Sigma_clean_epsi t2) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| epsi =&gt; t1'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| t2' =&gt; star t1' t2'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt; t<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Definition</span> <a name="Sigma_elt_eq"></a>Sigma_elt_eq (e1 e2: Sigma) (env: Pi) : bool :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> (e1,e2) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(epsi,epsi) =&gt; true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ((singl x1 x2),(singl x3 x4)) =&gt; (andb (expr_b_dp (env =b&gt; (x1 == x3))) (expr_b_dp (env =b&gt; (x2 == x4))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ((singl x1 x2),(cell x3)) =&gt; (expr_b_dp (env =b&gt; (x1 == x3))) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ((cell x1),(cell x3)) =&gt; (expr_b_dp (env =b&gt; (x1 == x3))) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (_,_) =&gt; false<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="Sigma_elt_term_extract"></a>Sigma_elt_term_extract (e t: Sigma) (env: Pi) {struct t}: option Sigma :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> t <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| star t1 t2 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> Sigma_elt_term_extract e t1 env <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; <span class="keyword">match</span> (Sigma_elt_term_extract e t2 env) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some t2' =&gt; Some (Sigma_clean_epsi (star t1 t2'))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some t1' =&gt; Some (Sigma_clean_epsi (star t1' t2))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt; <span class="keyword">if</span> (Sigma_elt_eq e t env) <span class="keyword">then</span> Some epsi <span class="keyword">else</span> None<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="Sigma_elt_term_extract'"></a>Sigma_elt_term_extract' (e t: Sigma) (env: Pi) {struct t}: option Sigma :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> t <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| star t1 t2 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> Sigma_elt_term_extract' e t1 env <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; <span class="keyword">match</span> (Sigma_elt_term_extract' e t2 env) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some t2' =&gt; Some (Sigma_clean_epsi (star t1 t2'))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some t1' =&gt; Some (Sigma_clean_epsi (star t1' t2))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt; <span class="keyword">if</span> Sigma_elt_eq t e env <span class="keyword">then</span> Some epsi <span class="keyword">else</span> None<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="Sigma_term_term_eq"></a>Sigma_term_term_eq (t1 t2: Sigma) (env: Pi) {struct t1}: option Sigma :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> t1 <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| star t11 t12 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> (Sigma_term_term_eq t11 t2 env) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; None <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some t2' =&gt; <span class="keyword">match</span> (Sigma_term_term_eq t12 t2' env) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some t2'' =&gt; Some t2''<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt; <span class="keyword">match</span> (Sigma_elt_term_extract t1 t2 env) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some t2' =&gt; Some t2'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="Sigma_get_cell_val"></a>Sigma_get_cell_val (e: expr) (sig: Sigma) (env: Pi) {struct sig}: option expr :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> sig <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| epsi =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| singl e1 e2 =&gt; <span class="keyword">if</span> (expr_b_dp (env =b&gt; (e1 == e))) <span class="keyword">then</span> (Some e2) <span class="keyword">else</span> None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (cell e1) =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| star s1 s2 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> (Sigma_get_cell_val e s1 env) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; (Sigma_get_cell_val e s2 env)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some e2 =&gt; Some e2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Definition</span> <a name="frag_decision"></a>frag_decision (P Q: Pi * Sigma) : bool :=<br/>
&nbsp;&nbsp;<span class="keyword">let</span> (pi1,sig1) := P <span class="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;( <span class="keyword">let</span> (pi2, sig2) := Q <span class="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span> (expr_b_dp (pi1 =b&gt; pi2)) <span class="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> (Sigma_term_term_eq sig1 sig2 pi1) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some epsi =&gt; true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt; false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span> false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="Sigma_clean_epsi_correct"></a>Sigma_clean_epsi_correct: forall t,<br/>
&nbsp;&nbsp;(Sigma_interp (Sigma_clean_epsi t) ==&gt; Sigma_interp t).<br/>

<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="Sigma_clean_epsi_correct'"></a>Sigma_clean_epsi_correct': forall t,<br/>
&nbsp;&nbsp;(Sigma_interp t ==&gt; Sigma_interp (Sigma_clean_epsi t)).<br/>

<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="Sigma_elt_eq_correct"></a>Sigma_elt_eq_correct: forall e1 e2 env,<br/>
&nbsp;&nbsp;Sigma_elt_eq e1 e2 env = true -&gt;<br/>
&nbsp;&nbsp;(forall s h,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(s |b= env) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(Sigma_interp e1 s h -&gt; Sigma_interp e2 s h)<br/>
&nbsp;&nbsp;).<br/>

<br/>
Opaque Sigma_clean_epsi.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="Sigma_elt_term_extract_correct"></a>Sigma_elt_term_extract_correct:<br/>
&nbsp;&nbsp;forall e2 e1 env e2',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Sigma_elt_term_extract e1 e2 env = Some e2' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall s h,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s |b= env) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Sigma_interp (star e1 e2') s h -&gt; Sigma_interp e2 s h)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;).<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="Sigma_elt_term_extract'_correct"></a>Sigma_elt_term_extract'_correct:<br/>
&nbsp;&nbsp;forall e2 e1 env e2',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Sigma_elt_term_extract' e1 e2 env = Some e2' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall s h,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s |b= env) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sigma_interp e2 s h -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sigma_interp (star e1 e2') s h<br/>
&nbsp;&nbsp;&nbsp;&nbsp;).<br/>

<br/>

<br/>

<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="Sigma_term_term_eq_correct"></a>Sigma_term_term_eq_correct: <br/>
&nbsp;&nbsp;forall t1 t2 env t1',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(Sigma_term_term_eq t1 t2 env = Some t1') -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall s h,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s |b= env) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Sigma_interp (star t1 t1') s h -&gt; Sigma_interp t2 s h)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;).<br/>

<br/>

<br/>

<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="Sigma_get_cell_val_correct"></a>Sigma_get_cell_val_correct: forall sig e env e',<br/>
&nbsp;&nbsp;Sigma_get_cell_val e sig env = Some e' -&gt;<br/>
&nbsp;&nbsp;(forall s h,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(s |b= env) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Sigma_interp sig s h -&gt; (Sigma_interp (singl e e') ** TT) s h).<br/>
&nbsp;&nbsp;Eval_b_hyp H.<br/>
&nbsp;&nbsp;Eval_b_hyp H0.<br/>

<br/>

<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="frag_decision_correct"></a>frag_decision_correct: forall P Q,<br/>
&nbsp;&nbsp;frag_decision P Q = true -&gt;<br/>
&nbsp;&nbsp;(assrt_interp P ==&gt; assrt_interp Q).<br/>

<br/>
Transparent Sigma_clean_epsi.<br/>

<br/>
<span class="keyword">Inductive</span> <a name="L_assrt"></a>L_assrt : <span class="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;<a name="L_elt"></a>L_elt : assrt -&gt; L_assrt<br/>
&nbsp;&nbsp;&nbsp;| <a name="L_subst"></a>L_subst : list (var.v * expr) -&gt; L_assrt -&gt; L_assrt<br/>
&nbsp;&nbsp;&nbsp;| L_lookup : var.v -&gt; expr -&gt; L_assrt -&gt; L_assrt<br/>
&nbsp;&nbsp;&nbsp;| L_mutation : expr -&gt; expr -&gt; L_assrt -&gt; L_assrt<br/>
&nbsp;&nbsp;&nbsp;| L_if : expr_b -&gt; L_assrt -&gt; L_assrt -&gt; L_assrt.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="subst_lst2update_store"></a>subst_lst2update_store (l:list (var.v * expr)) (P:assert) {struct l} : assert :=<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> l <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil =&gt; P<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (x,e)::tl =&gt; subst_lst2update_store tl (update_store2 x e P)<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store_app"></a>subst_lst2update_store_app : forall l2 l1 P s h,<br/>
&nbsp;&nbsp;&nbsp;subst_lst2update_store (l2 ++ l1) P s h -&gt;<br/>
&nbsp;&nbsp;&nbsp;subst_lst2update_store l1 (subst_lst2update_store l2 P) s h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store'"></a>subst_lst2update_store' : forall l x v s h P,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;subst_lst2update_store (l ++ (x,v)::nil) P s h -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;update_store2 x v (subst_lst2update_store l P) s h.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="L_assrt_interp"></a>L_assrt_interp (a: L_assrt) : assert :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> a <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="L_elt"></a>L_elt a1 =&gt; assrt_interp a1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| L_subst l L =&gt; subst_lst2update_store l (L_assrt_interp L)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| L_lookup x e L =&gt; (<span class="keyword">fun</span> s h =&gt; exists e0, (e |-&gt; e0 ** (e |-&gt; e0 -* (update_store2 x e0 (L_assrt_interp L)))) s h)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| L_mutation e1 e2 L =&gt; (<span class="keyword">fun</span> s h =&gt; exists e0, (e1 |-&gt; e0 ** (e1 |-&gt; e2 -* (L_assrt_interp L))) s h)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| L_if b L1 L2 =&gt; (<span class="keyword">fun</span> s h =&gt; (eval_b b s = true -&gt; L_assrt_interp L1 s h) /\ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval_b b s = false -&gt; L_assrt_interp L2 s h))<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="subst_e"></a>subst_e (e patt repl: expr) {struct e} : expr :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> e <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="var_e"></a>var_e w =&gt; <span class="keyword">match</span> expr_eq e patt <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="true"></a>true =&gt; repl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| false =&gt; e<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| int_e i =&gt; <span class="keyword">match</span> expr_eq e patt <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="true"></a>true =&gt; repl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| false =&gt; e<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| add_e e1 e2 =&gt; <span class="keyword">match</span> expr_eq e patt <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="true"></a>true =&gt; repl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| false =&gt; add_e (subst_e e1 patt repl) (subst_e e2 patt repl)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| min_e e1 e2 =&gt; <span class="keyword">match</span> expr_eq e patt <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="true"></a>true =&gt; repl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| false =&gt; min_e (subst_e e1 patt repl) (subst_e e2 patt repl)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| mul_e e1 e2 =&gt; <span class="keyword">match</span> expr_eq e patt <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="true"></a>true =&gt; repl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| false =&gt; mul_e (subst_e e1 patt repl) (subst_e e2 patt repl)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| div_e e1 e2 =&gt; <span class="keyword">match</span> expr_eq e patt <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="true"></a>true =&gt; repl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| false =&gt; div_e (subst_e e1 patt repl) (subst_e e2 patt repl)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| mod_e e1 e2 =&gt; <span class="keyword">match</span> expr_eq e patt <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="true"></a>true =&gt; repl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| false =&gt; mod_e (subst_e e1 patt repl) (subst_e e2 patt repl)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="subst_b"></a>subst_b (e: expr_b) (patt repl: expr) {struct e} : expr_b :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> e <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="true_b"></a>true_b =&gt; true_b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| f == g =&gt; subst_e f patt repl == subst_e g patt repl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| f =/= g =&gt; subst_e f patt repl =/= subst_e g patt repl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| f &gt;&gt;= g =&gt; subst_e f patt repl &gt;&gt;= subst_e g patt repl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| f &gt;&gt; g =&gt; subst_e f patt repl &gt;&gt; subst_e g patt repl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| f &amp;&amp;&amp; g =&gt; (subst_b f patt repl) &amp;&amp;&amp; (subst_b g patt repl)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| f ||| g =&gt; (subst_b f patt repl) ||| (subst_b g patt repl)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| neg_b e =&gt; neg_b (subst_b e patt repl)<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="subst_Sigma"></a>subst_Sigma (a: Sigma) (x: var.v) (e: expr) {struct a} : Sigma :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> a <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;singl e1 e2 =&gt; singl (subst_e e1 (var_e x) e) (subst_e e2 (var_e x) e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| epsi =&gt; epsi<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| star s1 s2 =&gt; star (subst_Sigma s1 x e) (subst_Sigma s2 x e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| cell e1 =&gt; cell (subst_e e1 (var_e x) e)<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Definition</span> <a name="subst_assrt"></a>subst_assrt (a: assrt) (x: var.v) (e: expr): assrt :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> a <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(pi, sigm) =&gt; (subst_b pi (var_e x) e, subst_Sigma sigm x e)<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="subst_assrt_lst"></a>subst_assrt_lst (l:list (var.v * expr)) (a:assrt) {struct l} : assrt :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> l <span class="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;nil =&gt; a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (x,e)::tl =&gt; subst_assrt_lst tl (subst_assrt a x e)<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="subst_e_lst"></a>subst_e_lst (l: list (var.v * expr)) (e: expr) {struct l}: expr :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> l <span class="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;nil =&gt; e<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (x,e')::tl =&gt; subst_e_lst tl (subst_e e (var_e x) e')<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="subst_b_lst"></a>subst_b_lst (l: list (var.v * expr)) (e: expr_b) {struct l}: expr_b :=<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> l <span class="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil =&gt; e<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (x,e')::tl =&gt; subst_b_lst tl (subst_b e (var_e x) e')<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_e2store_update"></a>subst_e2store_update: forall e s x v,<br/>
&nbsp;&nbsp;&nbsp;eval (subst_e e (var_e x) v) s = eval e (store.update x (eval v s) s).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_b2store_update"></a>subst_b2store_update: forall b s x v,<br/>
&nbsp;&nbsp;eval_b (subst_b b (var_e x) v) s = eval_b b (store.update x (eval v s) s).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_e_lst_int_e"></a>subst_e_lst_int_e: forall l v s,<br/>
&nbsp;&nbsp;eval (subst_e_lst l (int_e v)) s =  v.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_Sigma2store_update"></a>subst_Sigma2store_update: forall sigm s h x v,<br/>
&nbsp;&nbsp;Sigma_interp (subst_Sigma sigm x v) s h -&gt; <br/>
&nbsp;&nbsp;Sigma_interp sigm (store.update x (eval v s) s) h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_Sigma2store_update'"></a>subst_Sigma2store_update': forall sigm s h x v,<br/>
&nbsp;&nbsp;Sigma_interp sigm (store.update x (eval v s) s) h -&gt; <br/>
&nbsp;&nbsp;Sigma_interp (subst_Sigma sigm x v) s h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store_assrt_interp"></a>subst_lst2update_store_assrt_interp: forall l s h pi sigm,<br/>
&nbsp;&nbsp;assrt_interp (subst_assrt_lst l (pi, sigm)) s h -&gt;<br/>
&nbsp;&nbsp;subst_lst2update_store l (assrt_interp (pi, sigm)) s h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store_subst_b_lst"></a>subst_lst2update_store_subst_b_lst: forall (b':bool) l b s h,<br/>
&nbsp;&nbsp;subst_lst2update_store l (<span class="keyword">fun</span> s h =&gt; eval_b b s = b') s h -&gt;<br/>
&nbsp;&nbsp;eval_b (subst_b_lst l b) s = b'.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="entails_subst_lst2update_store"></a>entails_subst_lst2update_store: forall l P1 P2 s h,<br/>
&nbsp;&nbsp;&nbsp;(P1 ==&gt; P2) -&gt;<br/>
&nbsp;&nbsp;&nbsp;subst_lst2update_store l P1 s h -&gt;<br/>
&nbsp;&nbsp;&nbsp;subst_lst2update_store l P2 s h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store_and"></a>subst_lst2update_store_and: forall l P1 P2 s h,<br/>
&nbsp;&nbsp;subst_lst2update_store l (<span class="keyword">fun</span> s h =&gt; P1 s h /\ P2 s h) s h -&gt;<br/>
&nbsp;&nbsp;subst_lst2update_store l P1 s h /\ subst_lst2update_store l P2 s h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store_and'"></a>subst_lst2update_store_and': forall l P1 P2 s h,<br/>
&nbsp;&nbsp;subst_lst2update_store l P1 s h /\ subst_lst2update_store l P2 s h -&gt;<br/>
&nbsp;&nbsp;subst_lst2update_store l (<span class="keyword">fun</span> s h =&gt; P1 s h /\ P2 s h) s h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store_imply"></a>subst_lst2update_store_imply: forall l P1 P2 s h,<br/>
&nbsp;&nbsp;(subst_lst2update_store l P1 s h -&gt; subst_lst2update_store l P2 s h) -&gt;<br/>
&nbsp;&nbsp;subst_lst2update_store l (<span class="keyword">fun</span> s h =&gt; P1 s h -&gt; P2 s h) s h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store_exists"></a>subst_lst2update_store_exists: forall l (P: expr -&gt; assert) s h,<br/>
&nbsp;&nbsp;(exists x0, (subst_lst2update_store l (P x0)) s h) -&gt;<br/>
&nbsp;&nbsp;subst_lst2update_store l (<span class="keyword">fun</span> s h =&gt; exists e0, P e0 s h) s h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store_sep_con"></a>subst_lst2update_store_sep_con: forall l P1 P2 s h,<br/>
&nbsp;&nbsp;&nbsp;((<span class="keyword">fun</span> s h =&gt; subst_lst2update_store l P1 s h) ** (<span class="keyword">fun</span> s h =&gt; subst_lst2update_store l P2 s h)) s h -&gt;<br/>
&nbsp;&nbsp;&nbsp;subst_lst2update_store l (P1 ** P2) s h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store_mapsto"></a>subst_lst2update_store_mapsto: forall l e1 e2 s h,<br/>
&nbsp;&nbsp;(subst_e_lst l e1 |-&gt; subst_e_lst l e2) s h -&gt;<br/>
&nbsp;&nbsp;subst_lst2update_store l (e1 |-&gt; e2) s h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store_mapsto'"></a>subst_lst2update_store_mapsto': forall l e1 e2 s h,<br/>
&nbsp;&nbsp;&nbsp;subst_lst2update_store l (e1 |-&gt; e2) s h -&gt;<br/>
&nbsp;&nbsp;&nbsp;(subst_e_lst l e1 |-&gt; subst_e_lst l e2) s h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store_sepimp"></a>subst_lst2update_store_sepimp: forall l P1 P2 s h,<br/>
&nbsp;&nbsp;((<span class="keyword">fun</span> s h =&gt; subst_lst2update_store l P1 s h) -* (<span class="keyword">fun</span> s h =&gt; subst_lst2update_store l P2 s h)) s h -&gt;<br/>
&nbsp;&nbsp;subst_lst2update_store l (P1 -* P2) s h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store_lookup'"></a>subst_lst2update_store_lookup' : forall e x v s,<br/>
&nbsp;&nbsp;exists e', eval e s = eval (subst_e e' (var_e x) v) s.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store_lookup"></a>subst_lst2update_store_lookup: forall l e1 e2 s h P,<br/>
&nbsp;&nbsp;(exists e0, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;((subst_e_lst l e1 |-&gt; e0) ** <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(subst_e_lst l e1 |-&gt; subst_e_lst l e2 -* subst_lst2update_store l P)) s h) -&gt;<br/>
&nbsp;&nbsp;subst_lst2update_store l (<span class="keyword">fun</span> s' h' =&gt; exists e0, (e1 |-&gt; e0 ** (e1 |-&gt; e2 -* P)) s' h') s h.<br/>

<br/>
<span class="keyword">Module</span> <span class="keyword">Type</span> <a name="FRESH"></a>FRESH.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Parameter</span> <a name="fresh_e"></a>fresh_e : var.v -&gt; expr -&gt; <span class="keyword">Prop</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Parameter</span> <a name="fresh_b"></a>fresh_b : var.v -&gt; expr_b -&gt; <span class="keyword">Prop</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Parameter</span> <a name="fresh_Sigma"></a>fresh_Sigma : var.v -&gt; Sigma -&gt; <span class="keyword">Prop</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Parameter</span> <a name="fresh_assrt"></a>fresh_assrt : var.v -&gt; assrt -&gt; <span class="keyword">Prop</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Parameter</span> <a name="fresh_lst"></a>fresh_lst : var.v -&gt; (list (var.v * expr)) -&gt; <span class="keyword">Prop</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Parameter</span> <a name="fresh_L_assrt"></a>fresh_L_assrt : var.v -&gt; L_assrt -&gt; <span class="keyword">Prop</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Parameter</span> <a name="fresh_lst_decompose"></a>fresh_lst_decompose : forall x hd0 hd1 tl, fresh_lst x ((hd0,hd1)::tl) -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;fresh_e x hd1 /\ x &lt;&gt; hd0 /\ fresh_lst x tl.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Parameter</span> <a name="fresh_e_var_e_neq"></a>fresh_e_var_e_neq : forall x y, fresh_e x (var_e y) -&gt; x &lt;&gt; y.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Parameter</span> <a name="fresh_e_eval"></a>fresh_e_eval: forall e x v s, fresh_e x e -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;eval e (store.update x v s) = eval e s.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Parameter</span> <a name="fresh_L_assrt_inde"></a>fresh_L_assrt_inde: forall L x , fresh_L_assrt x L -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;inde (x::nil) (L_assrt_interp L).<br/>

<br/>
<span class="keyword">End</span> FRESH.<br/>

<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> Max.<br/>

<br/>
<span class="keyword">Module</span> <a name="Fresh"></a>Fresh &lt;: FRESH.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Fixpoint</span> <a name="Fresh.var_max_expr"></a>var_max_expr (e: expr) : var.v :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> e <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var_e w =&gt; w<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| int_e i =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| add_e e1 e2 =&gt; max (var_max_expr e1) (var_max_expr e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| min_e e1 e2 =&gt; max (var_max_expr e1) (var_max_expr e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| mul_e e1 e2 =&gt; max (var_max_expr e1) (var_max_expr e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| div_e e1 e2 =&gt; max (var_max_expr e1) (var_max_expr e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| mod_e e1 e2 =&gt; max (var_max_expr e1) (var_max_expr e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Fixpoint</span> <a name="Fresh.var_max_expr_b"></a>var_max_expr_b (e: expr_b) : var.v :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> e <span class="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true_b =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| eq_b e1 e2 =&gt; max (var_max_expr e1) (var_max_expr e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| neq_b e1 e2 =&gt; max (var_max_expr e1) (var_max_expr e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ge_b e1 e2 =&gt; max (var_max_expr e1) (var_max_expr e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| gt_b e1 e2 =&gt; max (var_max_expr e1) (var_max_expr e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| and_b e1 e2 =&gt; max (var_max_expr_b e1) (var_max_expr_b e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| or_b e1 e2 =&gt; max (var_max_expr_b e1) (var_max_expr_b e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| neg_b e =&gt; (var_max_expr_b e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Fixpoint</span> <a name="Fresh.var_max_Sigma"></a>var_max_Sigma (s: Sigma) : var.v :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> s <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;singl e1 e2 =&gt; max (var_max_expr e1) (var_max_expr e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| epsi =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| star s1 s2 =&gt; max (var_max_Sigma s1) (var_max_Sigma s2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| cell e1 =&gt; var_max_expr e1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Definition</span> <a name="Fresh.var_max_assrt"></a>var_max_assrt (a: assrt) : var.v :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> a <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pi, sigm) =&gt; max (var_max_expr_b pi) (var_max_Sigma sigm)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Fixpoint</span> <a name="Fresh.var_max_lst"></a>var_max_lst (l: list (var.v * expr)) : var.v :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> l <span class="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (v,e)::tl =&gt; max (max v (var_max_expr e)) (var_max_lst tl)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Fixpoint</span> <a name="Fresh.var_max_L_assrt"></a>var_max_L_assrt (a: L_assrt) : var.v :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> a <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L_elt a1 =&gt; var_max_assrt a1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| L_subst l L =&gt; max (var_max_lst l) (var_max_L_assrt L)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| L_lookup x e L=&gt; max (max x (var_max_expr e)) (var_max_L_assrt L)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| L_mutation e1 e2 L =&gt; max (max (var_max_expr e1) (var_max_expr e2)) (var_max_L_assrt L)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| L_if b L1 L2 =&gt; max (max (var_max_L_assrt L1) (var_max_L_assrt L2)) (var_max_expr_b b)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Definition</span> <a name="Fresh.fresh_e"></a>fresh_e x e := (x &gt; var_max_expr e).<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Definition</span> <a name="Fresh.fresh_b"></a>fresh_b x b := (x &gt; var_max_expr_b b).<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Definition</span> <a name="Fresh.fresh_Sigma"></a>fresh_Sigma x s := (x &gt; var_max_Sigma s).<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Definition</span> <a name="Fresh.fresh_assrt"></a>fresh_assrt x a := (x &gt; var_max_assrt a).<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Definition</span> <a name="Fresh.fresh_lst"></a>fresh_lst x l := (x &gt; var_max_lst l).<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Definition</span> <a name="Fresh.fresh_L_assrt"></a>fresh_L_assrt x L := (x &gt; var_max_L_assrt L).<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Lemma</span> <a name="Fresh.fresh_lst_decompose"></a>fresh_lst_decompose : forall x hd0 hd1 tl, fresh_lst x ((hd0,hd1)::tl) -&gt; fresh_e x hd1 /\ x &lt;&gt; hd0 /\ fresh_lst x tl.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Lemma</span> <a name="Fresh.fresh_e_var_e_neq"></a>fresh_e_var_e_neq : forall x y, fresh_e x (var_e y) -&gt; x &lt;&gt; y.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Ltac</span> Max_inf_resolve :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Max_inf_clean_hyp; Max_inf_resolve_goal<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>          <br/>
&nbsp;&nbsp;&nbsp;&nbsp;Max_inf_clean_hyp :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> goal <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| id: fresh_e _ _ |- _ =&gt; red <span class="keyword">in</span> id; simpl <span class="keyword">in</span> id; Max_inf_clean_hyp<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| id: fresh_b _ _ |- _ =&gt; red <span class="keyword">in</span> id; simpl <span class="keyword">in</span> id; Max_inf_clean_hyp<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| id: fresh_Sigma _ _ |- _ =&gt; red <span class="keyword">in</span> id; simpl <span class="keyword">in</span> id; Max_inf_clean_hyp<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| id: fresh_assrt _ _ |- _ =&gt; red <span class="keyword">in</span> id; simpl <span class="keyword">in</span> id; Max_inf_clean_hyp<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| id: fresh_lst _ _ |- _ =&gt; red <span class="keyword">in</span> id; simpl <span class="keyword">in</span> id; Max_inf_clean_hyp<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| id: fresh_L_assrt _ _ |- _ =&gt; red <span class="keyword">in</span> id; simpl <span class="keyword">in</span> id; Max_inf_clean_hyp<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| id: ?x &gt; max ?y ?z |- _ =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generalize (max_lemma2 _ _ _ id); intro X; inversion_clear X; clear id; Max_inf_clean_hyp<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- _ =&gt;  idtac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;Max_inf_resolve_goal := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> goal <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- fresh_e _ _ =&gt; red; simpl; Max_inf_resolve_goal<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- fresh_b _ _ =&gt; red; simpl; Max_inf_resolve_goal<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- fresh_Sigma _ _ =&gt; red; simpl; Max_inf_resolve_goal<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- fresh_assrt _ _ =&gt; red; simpl; Max_inf_resolve_goal<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- fresh_lst _ _ =&gt; red; simpl; Max_inf_resolve_goal<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- fresh_L_assrt _ _ =&gt; red; simpl; Max_inf_resolve_goal<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- ?x &gt; max ?y ?z =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eapply max_lemma3; split; [Max_inf_resolve_goal | Max_inf_resolve_goal]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- _ =&gt; omega || tauto || idtac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Lemma</span> <a name="Fresh.fresh_e_eval"></a>fresh_e_eval: forall e x v s,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fresh_e x e -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;eval e (store.update x v s) = eval e s.<br/>

<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Lemma</span> <a name="Fresh.fresh_b_inde"></a>fresh_b_inde: forall b x v,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fresh_b x b -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;inde (x::nil) (<span class="keyword">fun</span> s h =&gt; eval_b b s = v).<br/>

<br/>

<br/>

<br/>

<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Lemma</span> <a name="Fresh.var_max_Sigma_inde"></a>var_max_Sigma_inde: forall sigm x ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fresh_Sigma x sigm -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;inde (x::nil) (Sigma_interp sigm).<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Lemma</span> <a name="Fresh.fresh_assrt_inde"></a>fresh_assrt_inde: forall a x ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fresh_assrt x a -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;inde (x::nil) (assrt_interp a).<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Lemma</span> <a name="Fresh.fresh_lst_inde"></a>fresh_lst_inde: forall l P x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;inde (x::nil) P -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fresh_lst x l -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;inde (x::nil) (subst_lst2update_store l P).<br/>

<br/>

<br/>

<br/>
&nbsp;&nbsp;<span class="keyword">Lemma</span> <a name="Fresh.fresh_L_assrt_inde"></a>fresh_L_assrt_inde: forall L x ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fresh_L_assrt x L -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;inde (x::nil) (L_assrt_interp L).<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>
<span class="keyword">End</span> Fresh.<br/>

<br/>
<span class="keyword">Import</span> Fresh.<br/>

<br/>
<span class="keyword">Inductive</span> <a name="LWP"></a>LWP : assrt -&gt; L_assrt -&gt; <span class="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="LWP_entail"></a>LWP_entail: forall pi1 pi2 sig1 sig2, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(assrt_interp (pi1,sig1)) ==&gt; (assrt_interp (pi2,sig2)) -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,sig1) (L_elt (pi2,sig2))<br/>
<br/>
&nbsp;&nbsp;| <a name="LWP_precond_stre"></a>LWP_precond_stre: forall L1 L1' L2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(assrt_interp L1) ==&gt; (assrt_interp L1') -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP L1' L2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP L1 L2<br/>
<br/>
&nbsp;&nbsp;| <a name="LWP_if"></a>LWP_if: forall pi1 sig1 L1 L2 b,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1 &amp;&amp;&amp; b,sig1)  L1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1 &amp;&amp;&amp; (neg_b b),sig1) L2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,sig1) (L_if b L1 L2)<br/>
<br/>
&nbsp;&nbsp;| <a name="LWP_mutation"></a>LWP_mutation: forall pi1 sig1 e1 e2 e3 e4 L, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall s, eval_b pi1 s = true -&gt; eval_b (e1 == e3) s = true) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,star sig1 (singl e1 e4)) L -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,star sig1 (singl e1 e2)) (L_mutation e3 e4 L)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;| <a name="LWP_mutation'"></a>LWP_mutation': forall pi1 sig1 e1 e3 e4 L, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall s, eval_b pi1 s = true -&gt; eval_b (e1 == e3) s = true) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,star sig1 (singl e1 e4)) L -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,star sig1 (cell e1)) (L_mutation e3 e4 L)<br/>
<br/>
&nbsp;&nbsp;| <a name="LWP_lookup"></a>LWP_lookup: forall pi1 sig1 e1 e2 e x L, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall s, eval_b pi1 s = true -&gt; eval_b (e1 == e) s = true) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,star sig1 (singl e1 e2)) (L_subst ((x,e2)::nil) L) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,star sig1 (singl e1 e2)) (L_lookup x e L)<br/>
<br/>
&nbsp;&nbsp;| <a name="LWP_subst_elt"></a>LWP_subst_elt: forall pi1 pi2 sig1 sig2 l, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,sig1) (L_elt (subst_assrt_lst l (pi2,sig2))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,sig1) (L_subst l (L_elt (pi2,sig2)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;| <a name="LWP_subst_subst"></a>LWP_subst_subst: forall pi1 sig1 l1 l2 L, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,sig1) (L_subst (l2 ++ l1) L) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,sig1) (L_subst l1 (L_subst l2 L))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;| <a name="LWP_subst_lookup"></a>LWP_subst_lookup: forall pi1 sig1 e1 e2 e x x' l L,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall s, eval_b pi1 s = true -&gt; eval_b (e1 == (subst_e_lst l e)) s = true) -&gt;                     <br/>
&nbsp;&nbsp;&nbsp;&nbsp;fresh_lst x' l -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fresh_L_assrt x' L -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fresh_e x' (var_e x) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,star sig1 (singl e1 e2)) (L_subst ((x,(var_e x'))::l ++ ((x',e2)::nil)) L) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,star sig1 (singl e1 e2)) (L_subst l (L_lookup x e L))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;| <a name="LWP_subst_mutation"></a>LWP_subst_mutation: forall pi1 sig1 e1 e2 l L, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,sig1) (L_mutation (subst_e_lst l e1) (subst_e_lst l e2) (L_subst l L)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,sig1) (L_subst l (L_mutation e1 e2 L))<br/>
<br/>
&nbsp;&nbsp;| <a name="LWP_subst_if"></a>LWP_subst_if: forall pi1 sig1 l b L1 L2, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,sig1)  (L_if (subst_b_lst l b) (L_subst l L1) (L_subst l L2)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;LWP (pi1,sig1) (L_subst l (L_if b L1 L2)).<br/>

<br/>
<span class="keyword">Ltac</span> apply_entails_subst_lst2update_store id :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> goal <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| id: subst_lst2update_store ?l ?P' ?s ?h |- subst_lst2update_store ?l ?P ?s ?h =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eapply entails_subst_lst2update_store <span class="keyword">with</span> P'; [red; simpl; intros; idtac | auto]<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Ltac</span> cut_replace_list P :=<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> goal <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- subst_lst2update_store ?l ?P' ?s ?h =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cut (subst_lst2update_store l P s h); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[intro cut_replace_listA1; apply_entails_subst_lst2update_store cut_replace_listA1 | idtac]<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store_fresh"></a>subst_lst2update_store_fresh: forall l x' e s h P,<br/>
&nbsp;&nbsp;&nbsp;fresh_lst x' l -&gt;<br/>
&nbsp;&nbsp;&nbsp;subst_lst2update_store l P (store.update x' (eval e s) s) h -&gt;<br/>
&nbsp;&nbsp;&nbsp;subst_lst2update_store l (<span class="keyword">fun</span> s' h' =&gt; P (store.update x' (eval e s) s') h') s h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_lst2update_store_fresh'"></a>subst_lst2update_store_fresh': forall l x' e s h P,<br/>
&nbsp;&nbsp;fresh_lst x' l -&gt;<br/>
&nbsp;&nbsp;subst_lst2update_store l (<span class="keyword">fun</span> s' h' =&gt; P (store.update x' (eval e s) s') h') s h -&gt;<br/>
&nbsp;&nbsp;subst_lst2update_store l P (store.update x' (eval e s) s) h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="intro_fresh_var'"></a>intro_fresh_var' : forall l x x' e s h P,<br/>
&nbsp;&nbsp;fresh_lst x' l -&gt;<br/>
&nbsp;&nbsp;fresh_e x' (var_e x) -&gt;<br/>
&nbsp;&nbsp;inde (x'::nil) P -&gt; <br/>
&nbsp;&nbsp;subst_lst2update_store l (<span class="keyword">fun</span> s' h' =&gt; P (store.update x (eval (var_e x') s') s') h') (store.update x' (eval e s) s) h -&gt;<br/>
&nbsp;&nbsp;subst_lst2update_store l (<span class="keyword">fun</span> s' h' =&gt; P (store.update x (eval e s) s') h') s h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="intro_fresh_var"></a>intro_fresh_var : forall l x x' e s h L,<br/>
&nbsp;&nbsp;&nbsp;fresh_lst x' l -&gt; fresh_L_assrt x' L -&gt; fresh_e x' (var_e x) -&gt;<br/>
&nbsp;&nbsp;&nbsp;subst_lst2update_store <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l (<span class="keyword">fun</span> s' h' =&gt; L_assrt_interp L (store.update x (eval (var_e x') s') s') h') (store.update x' (eval e s) s) h -&gt;<br/>
&nbsp;&nbsp;&nbsp;subst_lst2update_store <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l (<span class="keyword">fun</span> s' h' =&gt; L_assrt_interp L (store.update x (eval e s) s') h') s h.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="LWP_soundness"></a>LWP_soundness: forall P Q, LWP P Q -&gt; <br/>
&nbsp;&nbsp;(assrt_interp P) ==&gt; (L_assrt_interp Q).<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="wp_frag"></a>wp_frag (Q: option L_assrt) (c: cmd) {struct c}: option L_assrt :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> c <span class="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="skip"></a>skip =&gt; <span class="keyword">match</span> Q <span class="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="None"></a>None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some Q' =&gt; Some Q'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| assign v e =&gt; <span class="keyword">match</span> Q <span class="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="None"></a>None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some Q' =&gt; Some (L_subst ((v,e)::nil) Q')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| lookup v e =&gt; <span class="keyword">match</span> Q <span class="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="None"></a>None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some Q' =&gt; Some (L_lookup v e Q')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| mutation e1 e2 =&gt; <span class="keyword">match</span> Q <span class="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="None"></a>None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some Q' =&gt; Some (L_mutation e1 e2 Q')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| seq c1 c2 =&gt; wp_frag (wp_frag Q c2) c1 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ifte b thendo c1 elsedo c2 =&gt; <span class="keyword">match</span> (wp_frag Q c1) <span class="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="None"></a>None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some Q1 =&gt; <span class="keyword">match</span> (wp_frag Q c2) <span class="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="None"></a>None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some Q2 =&gt; Some (L_if b (Q1) (Q2))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| while a c =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| malloc v e =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| free e =&gt; None<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="wp_frag_None_is_None"></a>wp_frag_None_is_None: forall c,  wp_frag None c = None.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="wp_frag_soudness"></a>wp_frag_soudness: forall c Q Q', <br/>
&nbsp;&nbsp;wp_frag (Some Q) c = Some Q' -&gt; {{ L_assrt_interp Q' }} c {{ L_assrt_interp Q }}.<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="LWP_use"></a>LWP_use: forall c P Q R, <br/>
&nbsp;&nbsp;wp_frag (Some (L_elt Q)) c = Some R -&gt; <br/>
&nbsp;&nbsp;LWP P R -&gt; <br/>
&nbsp;&nbsp;{{ assrt_interp P }} c {{ assrt_interp Q }}.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="LWP_subst_lookup'"></a>LWP_subst_lookup' : forall pi1 sig1 e1 e2 e x x' l L,<br/>
&nbsp;&nbsp;(forall s,eval_b pi1 s = true -&gt; (eval_b (e1 == (subst_e_lst l e))) s = true) -&gt;                     <br/>
&nbsp;&nbsp;x' = (max (max (var_max_lst l) (var_max_L_assrt L)) x) + 1 -&gt;<br/>
&nbsp;&nbsp;LWP (pi1,star sig1 (singl e1 e2)) (L_subst ((x,(var_e x'))::l ++ ((x',e2)::nil)) L) -&gt;<br/>
&nbsp;&nbsp;LWP (pi1,star sig1 (singl e1 e2)) (L_subst l (L_lookup x e L)).<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="Sigma_assoc_left"></a>Sigma_assoc_left (t t': Sigma) {struct t}: Sigma :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> t <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="star"></a>star sig1 sig2 =&gt; Sigma_assoc_left (sig2) (star t' sig1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt; <span class="keyword">match</span> t' <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="epsi"></a>epsi =&gt; t<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt; star t' t<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Definition</span> <a name="Sigma_com"></a>Sigma_com (t: Sigma) : Sigma :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> t <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;star sig1 sig2 =&gt; star sig2 sig1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt; t<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Ltac</span> Rotate_LWP_sig_lhs :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> goal <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- LWP (?pi,?sig) ?L' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eapply LWP_precond_stre <span class="keyword">with</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pi, Sigma_clean_epsi (Sigma_assoc_left (Sigma_com sig) epsi))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;); [apply ps1_soundness; simpl; ps1_Resolve| simpl]<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Ltac</span> LWP_resolve := <br/>
&nbsp;&nbsp;<span class="keyword">match</span> goal <span class="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- LWP (?pi1, ?sig1) (L_elt (?pi2, ?sig2)) =&gt; eapply LWP_entail; [eapply ps1_soundness; ps1_Resolve]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- LWP (?pi1, star ?sig1 (singl ?e1 ?e2)) (L_mutation ?e3 ?e4 ?L') =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eapply LWP_mutation; [Omega_exprb | LWP_resolve] || Rotate_LWP_sig_lhs; idtac)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- LWP (?pi1, star ?sig1 (cell ?e1)) (L_mutation ?e3 ?e4 ?L') =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eapply LWP_mutation'; [Omega_exprb | LWP_resolve] || Rotate_LWP_sig_lhs; idtac)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- LWP (?pi1, star ?sig1 (singl ?e1 ?e2)) (L_lookup ?x ?e ?L') =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eapply LWP_lookup; [Omega_exprb | LWP_resolve] || Rotate_LWP_sig_lhs; idtac)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- LWP ?L (L_subst ?l (L_elt ?L')) =&gt; eapply LWP_subst_elt; simpl; idtac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- LWP ?L (L_subst ?l (L_subst ?l' ?L')) =&gt; eapply LWP_subst_subst; simpl; idtac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- LWP ?L (L_subst ?l (L_lookup ?x ?e ?L')) =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eapply LWP_subst_lookup'; [Omega_exprb | simpl; intuition | LWP_resolve] || Rotate_LWP_sig_lhs; idtac)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- LWP ?L (L_subst ?l (L_mutation ?e1 ?e2 ?L')) =&gt; eapply LWP_subst_mutation; simpl; idtac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- LWP ?L (L_subst ?l (L_if ?b ?L1 ?L2)) =&gt; eapply LWP_subst_if; simpl; idtac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- LWP ?L (L_if ?b ?L1 ?L2) =&gt; eapply LWP_if; simpl; idtac<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Ltac</span> LWP_Resolve := Rotate_LWP_sig_lhs; repeat LWP_resolve.<br/>

<br/>
<span class="keyword">Definition</span> <a name="LWP_step"></a>LWP_step (pi: Pi) (sig: Sigma) (A: L_assrt) : option (list ((Pi * Sigma) * L_assrt)) :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> A <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| L_elt L =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span> (frag_decision (pi,sig) L) <span class="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some nil <span class="keyword">else</span> None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| L_subst l L =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> L <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| L_elt L' =&gt; Some (((pi,sig), L_elt (subst_assrt_lst l L'))::nil) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| L_subst l' L' =&gt; Some (((pi,sig), L_subst (l'++ l) L')::nil)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| L_lookup x e L' =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> (Sigma_get_cell_val (subst_e_lst l e) sig pi) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some e' =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>   x' := (max (max (var_max_lst l) (var_max_L_assrt L')) x) + 1 <span class="keyword">in</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some (((pi,sig),(L_subst ((x,(var_e x'))::l ++ ((x',e')::nil)) L'))::nil)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| L_mutation e1 e2 L' =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some (((pi,sig),(L_mutation (subst_e_lst l e1) (subst_e_lst l e2) (L_subst l L')))::nil)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| L_if b L1 L2 =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some (((pi,sig), L_if (subst_b_lst l b) (L_subst l L1) (L_subst l L2))::nil)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| L_lookup x e L =&gt;       <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> (Sigma_get_cell_val e sig pi) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some e' =&gt; Some (((pi,sig),(L_subst ((x,e')::nil) L))::nil)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| L_mutation e1 e2 L =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> (Sigma_elt_term_extract' (cell e1) sig pi) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some sig' =&gt; Some (((pi,star (singl e1 e2) sig'),L)::nil)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| L_if b L1 L2 =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some (((pi &amp;&amp;&amp; b,sig),L1)::((pi &amp;&amp;&amp; (! b),sig),L2)::nil)<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="L_assrt_size"></a>L_assrt_size (A: L_assrt) : nat :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> A <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="L_elt"></a>L_elt P =&gt; 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| L_subst l P =&gt; 2 + L_assrt_size P<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| L_lookup x e P =&gt; 2 + L_assrt_size P<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| L_mutation e1 e2 P  =&gt; 2 + L_assrt_size P<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| L_if b L1 L2 =&gt; 2 + L_assrt_size L1 + L_assrt_size L2<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="LWP_list"></a>LWP_list (l: (list ((Pi * Sigma) * L_assrt))) : option (list ((Pi * Sigma) * L_assrt)) :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> l <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| nil =&gt; Some nil<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ((pi,sig),A)::tl =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> (LWP_step pi sig A) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some l' =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> (LWP_list tl) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some l'' =&gt; Some (l' ++ l'')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="LWP_list_rec"></a>LWP_list_rec (l: (list ((Pi * Sigma) * L_assrt))) (size: nat) {struct size}: option (list ((Pi * Sigma) * L_assrt)) :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> size <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; Some l<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| S size' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> (LWP_list l) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some l' =&gt; LWP_list_rec l' size'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Definition</span> <a name="frag_hoare"></a>frag_hoare (P Q: Pi * Sigma) (c: cmd) : bool :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> (wp_frag (Some (L_elt Q)) c) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Some L =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span> (p,s) := P <span class="keyword">in</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> (LWP_list_rec (((p,s),L)::nil) (L_assrt_size L)) <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some nil =&gt; true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt; false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
Opaque frag_decision.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="LWP_step_correct"></a>LWP_step_correct: forall pi sig A l,<br/>
&nbsp;&nbsp;LWP_step pi sig A = Some l -&gt;<br/>
&nbsp;&nbsp;(forall pi' sig' A', <br/>
&nbsp;&nbsp;&nbsp;&nbsp;In ((pi',sig'),A') l -&gt; ((assrt_interp (pi',sig')) ==&gt; (L_assrt_interp A'))    <br/>
&nbsp;&nbsp;) -&gt;<br/>
&nbsp;&nbsp;((assrt_interp (pi,sig)) ==&gt; (L_assrt_interp A)).<br/>

<br/>

<br/>
Transparent frag_decision.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="LWP_list_correct"></a>LWP_list_correct: forall l l',<br/>
&nbsp;&nbsp;LWP_list l = Some l' -&gt;<br/>
&nbsp;&nbsp;(forall pi sig A, In ((pi,sig),A) l' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;((assrt_interp (pi,sig)) ==&gt; (L_assrt_interp A))) -&gt;<br/>
&nbsp;&nbsp;(forall pi sig A, In ((pi,sig),A) l -&gt; ((assrt_interp (pi,sig)) ==&gt; (L_assrt_interp A))).<br/>

<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="LWP_list_rec_correct"></a>LWP_list_rec_correct: forall a l l',<br/>
&nbsp;&nbsp;LWP_list_rec l a = Some l' -&gt;<br/>
&nbsp;&nbsp;(forall pi sig A, In ((pi,sig),A) l' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;((assrt_interp (pi,sig)) ==&gt; (L_assrt_interp A))) -&gt;<br/>
&nbsp;&nbsp;(forall pi sig A, In ((pi,sig),A) l -&gt; ((assrt_interp (pi,sig)) ==&gt; (L_assrt_interp A))).<br/>

<br/>

<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="frag_hoare_correct"></a>frag_hoare_correct: forall P Q c,<br/>
&nbsp;&nbsp;frag_hoare P Q c = true -&gt;<br/>
&nbsp;&nbsp;{{assrt_interp P}}<br/>
&nbsp;&nbsp;c<br/>
&nbsp;&nbsp;{{assrt_interp Q}}.<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>
</code>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/><font size="-1">This page has been generated by <a href="http://coq.inria.fr">coqdoc</a></font>
</div>

</div>

</body>
</html>