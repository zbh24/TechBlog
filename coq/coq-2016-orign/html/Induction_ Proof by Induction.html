<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0059)http://www.seas.upenn.edu/~cis500/current/sf/Induction.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<link href="./Induction_ Proof by Induction_files/coqdoc.css" rel="stylesheet" type="text/css">
<title>Induction: Proof by Induction</title>
<script type="text/javascript" src="./Induction_ Proof by Induction_files/jquery-1.8.3.js"></script>
<script type="text/javascript" src="./Induction_ Proof by Induction_files/main.js"></script>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Induction<span class="subtitle">Proof by Induction</span></h1>

<div class="code code-tight">
</div>

<div class="doc">

<div class="paragraph"> </div>

 The next line imports all of our definitions from the
    previous chapter. 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#"><span class="id" type="library">Basics</span></a>.<br>

<br>
</div>

<div class="doc">
For it to work, you need to use <span class="inlinecode"><span class="id" type="var">coqc</span></span> to compile <span class="inlinecode"><span class="id" type="var">Basics.v</span></span>
    into <span class="inlinecode"><span class="id" type="var">Basics.vo</span></span>.  This is like making a .class file from a .java
    file, or a .o file from a .c file.

<div class="paragraph"> </div>

    Here are two ways to compile your code:

<div class="paragraph"> </div>

<ul class="doclist">
<li> In CoqIDE:

<div class="paragraph"> </div>

         Open <span class="inlinecode"><span class="id" type="var">Basics.v</span></span>.
         In the "Compile" menu, click on "Compile Buffer".

<div class="paragraph"> </div>


</li>
<li> From the command line:

<div class="paragraph"> </div>

         Run <span class="inlinecode"><span class="id" type="var">coqc</span></span> <span class="inlinecode"><span class="id" type="var">Basics.v</span></span>

</li>
</ul>

<div class="paragraph"> </div>

    
</div>
<div class="code code-tight">

<br>
</div>

<div class="doc">
<a name="lab40"></a><h1 class="section">Proof by Induction</h1>

<div class="paragraph"> </div>

 We proved in the last chapter that <span class="inlinecode">0</span> is a neutral element
    for <span class="inlinecode">+</span> on the left using an easy argument based on
    simplification.  The fact that it is also a neutral element on the
    <i>right</i>... 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_n_O_firsttry"><span class="id" type="lemma">plus_n_O_firsttry</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + 0.<br>

<br>
</div>

<div class="doc">
... cannot be proved in the same simple way.  Just applying
  <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> doesn't work, since the <span class="inlinecode"><span class="id" type="var">n</span></span> in <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> is an arbitrary
  unknown number, so the <span class="inlinecode"><span class="id" type="keyword">match</span></span> in the definition of <span class="inlinecode">+</span> can't be
  simplified.  
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="comment">(*&nbsp;Does&nbsp;nothing!&nbsp;*)</span><br>
<span class="id" type="keyword">Abort</span>.<br>

<br>
</div>

<div class="doc">
And reasoning by cases using <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> doesn't get us much
   further: the branch of the case analysis where we assume <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>
   goes through fine, but in the branch where <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> for some <span class="inlinecode"><span class="id" type="var">n'</span></span> we
   get stuck in exactly the same way.  We could use <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> to
   get one step further, but, since <span class="inlinecode"><span class="id" type="var">n</span></span> can be arbitrarily large, if we
   try to keep on like this we'll never be done. 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_n_O_secondtry"><span class="id" type="lemma">plus_n_O_secondtry</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + 0.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;0&nbsp;*)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="comment">(*&nbsp;so&nbsp;far&nbsp;so&nbsp;good...&nbsp;*)</span><br>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;S&nbsp;n'&nbsp;*)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="comment">(*&nbsp;...but&nbsp;here&nbsp;we&nbsp;are&nbsp;stuck&nbsp;again&nbsp;*)</span><br>
<span class="id" type="keyword">Abort</span>.<br>

<br>
</div>

<div class="doc">
To prove interesting facts about numbers, lists, and other
    inductively defined sets, we usually need a more powerful
    reasoning principle: <i>induction</i>.

<div class="paragraph"> </div>

    Recall (from high school, a discrete math course, etc.) the
    principle of induction over natural numbers: If <span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">n</span>)</span> is some
    proposition involving a natural number <span class="inlinecode"><span class="id" type="var">n</span></span> and we want to show
    that <span class="inlinecode"><span class="id" type="var">P</span></span> holds for <i>all</i> numbers <span class="inlinecode"><span class="id" type="var">n</span></span>, we can reason like this:

<div class="paragraph"> </div>

<ul class="doclist">
<li> show that <span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">O</span>)</span> holds;

</li>
<li> show that, for any <span class="inlinecode"><span class="id" type="var">n'</span></span>, if <span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">n'</span>)</span> holds, then so does
           <span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span>;

</li>
<li> conclude that <span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">n</span>)</span> holds for all <span class="inlinecode"><span class="id" type="var">n</span></span>.

</li>
</ul>

<div class="paragraph"> </div>

    In Coq, the steps are the same but the order is backwards: we
    begin with the goal of proving <span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">n</span>)</span> for all <span class="inlinecode"><span class="id" type="var">n</span></span> and break it
    down (by applying the <span class="inlinecode"><span class="id" type="tactic">induction</span></span> tactic) into two separate
    subgoals: first showing <span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">O</span>)</span> and then showing <span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">n'</span>)</span> <span class="inlinecode"><span style="font-family: arial;">→</span></span> <span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">S</span></span>
    <span class="inlinecode"><span class="id" type="var">n'</span>)</span>.  Here's how this works for the theorem at hand: 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_n_O"><span class="id" type="lemma">plus_n_O</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + 0.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">IHn'</span>].<br>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;0&nbsp;*)</span>    <span class="id" type="tactic">reflexivity</span>.<br>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;S&nbsp;n'&nbsp;*)</span> <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">←</span> <span class="id" type="var">IHn'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
Like <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>, the <span class="inlinecode"><span class="id" type="tactic">induction</span></span> tactic takes an <span class="inlinecode"><span class="id" type="keyword">as</span>...</span>
    clause that specifies the names of the variables to be introduced
    in the subgoals.  In the first branch, <span class="inlinecode"><span class="id" type="var">n</span></span> is replaced by <span class="inlinecode">0</span> and
    the goal becomes <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>, which follows by simplification.  In
    the second, <span class="inlinecode"><span class="id" type="var">n</span></span> is replaced by <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> and the assumption <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" type="var">n'</span></span> is added to the context (with the name <span class="inlinecode"><span class="id" type="var">IHn'</span></span>, i.e., the
    Induction Hypothesis for <span class="inlinecode"><span class="id" type="var">n'</span></span> — notice that this name is
    explicitly chosen in the <span class="inlinecode"><span class="id" type="keyword">as</span>...</span> clause of the call to <span class="inlinecode"><span class="id" type="tactic">induction</span></span>
    rather than letting Coq choose one arbitrarily). The goal in this
    case becomes <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span>, which simplifies to <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">n'</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0)</span>
    <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span>, which in turn follows from <span class="inlinecode"><span class="id" type="var">IHn'</span></span>. 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Theorem</span> <a name="minus_diag"><span class="id" type="lemma">minus_diag</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span>,<br>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#minus"><span class="id" type="definition">minus</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> = 0.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">IHn'</span>].<br>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;0&nbsp;*)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>.<br>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;S&nbsp;n'&nbsp;*)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <span class="id" type="var">IHn'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
<a name="lab41"></a><h4 class="section">Exercise: 2 stars, recommended (basic_induction)</h4>
 Prove the following using induction. You might need previously
    proven results. 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Theorem</span> <a name="mult_0_r"><span class="id" type="lemma">mult_0_r</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> * 0 = 0.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_n_Sm"><span class="id" type="lemma">plus_n_Sm</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <br>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a>) = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a>).<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_comm"><span class="id" type="lemma">plus_comm</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a> = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_assoc"><span class="id" type="lemma">plus_assoc</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a>) = (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a>) + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
<div class="paragraph"> </div>

<a name="lab42"></a><h4 class="section">Exercise: 2 stars (double_plus)</h4>
 Consider the following function, which doubles its argument: 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Fixpoint</span> <a name="double"><span class="id" type="definition">double</span></a> (<span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a><br>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n'</span> ⇒ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#double"><span class="id" type="definition">double</span></a> <span class="id" type="var">n'</span>))<br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
</div>

<div class="doc">
Use induction to prove this simple fact about <span class="inlinecode"><span class="id" type="var">double</span></span>: 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Lemma</span> <a name="double_plus"><span class="id" type="lemma">double_plus</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span>, <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> .<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
<div class="paragraph"> </div>

<a name="lab43"></a><h4 class="section">Exercise: 2 stars, optional (evenb_S)</h4>
 One inconveninent aspect of our definition of <span class="inlinecode"><span class="id" type="var">evenb</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> is that it
    may need to perform a recursive call on <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode">2</span>. This makes proofs
    about <span class="inlinecode"><span class="id" type="var">evenb</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> harder when done by induction on <span class="inlinecode"><span class="id" type="var">n</span></span>, since we may
    need an induction hypothesis about <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode">2</span>. The following lemma
    gives a better characterization of <span class="inlinecode"><span class="id" type="var">evenb</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span>: 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Theorem</span> <a name="evenb_S"><span class="id" type="lemma">evenb_S</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#evenb"><span class="id" type="definition">evenb</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a>) = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#negb"><span class="id" type="definition">negb</span></a> (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#evenb"><span class="id" type="definition">evenb</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a>).<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
<div class="paragraph"> </div>

<a name="lab44"></a><h4 class="section">Exercise: 1 star (destruct_induction)</h4>
 Briefly explain the difference between the tactics
    <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> and <span class="inlinecode"><span class="id" type="tactic">induction</span></span>.

<div class="paragraph"> </div>

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br>

<div class="paragraph"> </div>

 <font size="-2">☐</font> 
</div>
<div class="code code-tight">

<br>
</div>

<div class="doc">
<a name="lab45"></a><h1 class="section">Proofs Within Proofs</h1>

<div class="paragraph"> </div>

 In Coq, as in informal mathematics, large proofs are often
    broken into a sequence of theorems, with later proofs referring to
    earlier theorems.  But sometimes a proof will require some
    miscellaneous fact that is too trivial and of too little general
    interest to bother giving it its own top-level name.  In such
    cases, it is convenient to be able to simply state and prove the
    needed "sub-theorem" right at the point where it is used.  The
    <span class="inlinecode"><span class="id" type="tactic">assert</span></span> tactic allows us to do this.  For example, our earlier
    proof of the <span class="inlinecode"><span class="id" type="var">mult_0_plus</span></span> theorem referred to a previous theorem
    named <span class="inlinecode"><span class="id" type="var">plus_O_n</span></span>.  We could instead use <span class="inlinecode"><span class="id" type="tactic">assert</span></span> to state and
    prove <span class="inlinecode"><span class="id" type="var">plus_O_n</span></span> in-line: 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Theorem</span> <a name="mult_0_plus&#39;"><span class="id" type="lemma">mult_0_plus'</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;(0 + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a>) * <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a> = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> * <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span>: 0 + <span class="id" type="var">n</span> = <span class="id" type="var">n</span>). { <span class="id" type="tactic">reflexivity</span>. }<br>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <span class="id" type="var">H</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="tactic">assert</span></span> tactic introduces two sub-goals.  The first is
    the assertion itself; by prefixing it with <span class="inlinecode"><span class="id" type="var">H</span>:</span> we name the
    assertion <span class="inlinecode"><span class="id" type="var">H</span></span>.  (We can also name the assertion with <span class="inlinecode"><span class="id" type="keyword">as</span></span> just as
    we did above with <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> and <span class="inlinecode"><span class="id" type="tactic">induction</span></span>, i.e., <span class="inlinecode"><span class="id" type="tactic">assert</span></span> <span class="inlinecode">(0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span>
    <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>.)  Note that we surround the proof of this assertion
    with curly braces <span class="inlinecode">{</span> <span class="inlinecode">...</span> <span class="inlinecode">}</span>, both for readability and so that,
    when using Coq interactively, we can see more easily when we have
    finished this sub-proof.  The second goal is the same as the one
    at the point where we invoke <span class="inlinecode"><span class="id" type="tactic">assert</span></span> except that, in the context,
    we now have the assumption <span class="inlinecode"><span class="id" type="var">H</span></span> that <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n</span></span>.  That is,
    <span class="inlinecode"><span class="id" type="tactic">assert</span></span> generates one subgoal where we must prove the asserted
    fact and a second subgoal where we can use the asserted fact to
    make progress on whatever we were trying to prove in the first
    place. 
<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" type="tactic">assert</span></span> tactic is handy in many sorts of situations.  For
    example, suppose we want to prove that <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode">(<span class="id" type="var">p</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">q</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode">(<span class="id" type="var">m</span></span> <span class="inlinecode">+</span>
    <span class="inlinecode"><span class="id" type="var">n</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode">(<span class="id" type="var">p</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">q</span>)</span>. The only difference between the two sides of the
    <span class="inlinecode">=</span> is that the arguments <span class="inlinecode"><span class="id" type="var">m</span></span> and <span class="inlinecode"><span class="id" type="var">n</span></span> to the first inner <span class="inlinecode">+</span> are
    swapped, so it seems we should be able to use the commutativity of
    addition (<span class="inlinecode"><span class="id" type="var">plus_comm</span></span>) to rewrite one into the other.  However,
    the <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> tactic is a little stupid about <i>where</i> it applies
    the rewrite.  There are three uses of <span class="inlinecode">+</span> here, and it turns out
    that doing <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode"><span style="font-family: arial;">→</span></span> <span class="inlinecode"><span class="id" type="var">plus_comm</span></span> will affect only the <i>outer</i>
    one... 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_rearrange_firsttry"><span class="id" type="lemma">plus_rearrange_firsttry</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> <span class="id" type="var">q</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;(<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a>) + (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#q"><span class="id" type="variable">q</span></a>) = (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a>) + (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#q"><span class="id" type="variable">q</span></a>).<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> <span class="id" type="var">q</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;We&nbsp;just&nbsp;need&nbsp;to&nbsp;swap&nbsp;(n&nbsp;+&nbsp;m)&nbsp;for&nbsp;(m&nbsp;+&nbsp;n)...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;seems&nbsp;like&nbsp;plus_comm&nbsp;should&nbsp;do&nbsp;the&nbsp;trick!&nbsp;*)</span><br>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Doesn't&nbsp;work...Coq&nbsp;rewrote&nbsp;the&nbsp;wrong&nbsp;plus!&nbsp;*)</span><br>
<span class="id" type="keyword">Abort</span>.<br>

<br>
</div>

<div class="doc">
To get <span class="inlinecode"><span class="id" type="var">plus_comm</span></span> to apply at the point where we want it to, we
    can introduce a local lemma stating that <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span> (for the
    particular <span class="inlinecode"><span class="id" type="var">m</span></span> and <span class="inlinecode"><span class="id" type="var">n</span></span> that we are talking about here), prove this
    lemma using <span class="inlinecode"><span class="id" type="var">plus_comm</span></span>, and then use it to do the desired
    rewrite. 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_rearrange"><span class="id" type="lemma">plus_rearrange</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> <span class="id" type="var">q</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;(<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a>) + (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#q"><span class="id" type="variable">q</span></a>) = (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a>) + (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#q"><span class="id" type="variable">q</span></a>).<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> <span class="id" type="var">q</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span>: <span class="id" type="var">n</span> + <span class="id" type="var">m</span> = <span class="id" type="var">m</span> + <span class="id" type="var">n</span>).<br>
&nbsp;&nbsp;{ <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a>. <span class="id" type="tactic">reflexivity</span>. }<br>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
<a name="lab46"></a><h1 class="section">More Exercises</h1>

<div class="paragraph"> </div>

<a name="lab47"></a><h4 class="section">Exercise: 3 stars, recommended (mult_comm)</h4>
 Use <span class="inlinecode"><span class="id" type="tactic">assert</span></span> to help prove this theorem.  You shouldn't need to
    use induction on <span class="inlinecode"><span class="id" type="var">plus_swap</span></span>. 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_swap"><span class="id" type="lemma">plus_swap</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a>) = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a> + (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a>).<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>

<br>
</div>

<div class="doc">
Now prove commutativity of multiplication.  (You will probably
    need to define and prove a separate subsidiary theorem to be used
    in the proof of this one.  You may find that <span class="inlinecode"><span class="id" type="var">plus_swap</span></span> comes in
    handy.) 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Theorem</span> <a name="mult_comm"><span class="id" type="lemma">mult_comm</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">m</span> <span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a> * <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> * <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
<div class="paragraph"> </div>

<a name="lab48"></a><h4 class="section">Exercise: 3 stars, optional (more_exercises)</h4>
 Take a piece of paper.  For each of the following theorems, first
    <i>think</i> about whether (a) it can be proved using only
    simplification and rewriting, (b) it also requires case
    analysis (<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>), or (c) it also requires induction.  Write
    down your prediction.  Then fill in the proof.  (There is no need
    to turn in your piece of paper; this is just to encourage you to
    reflect before you hack!) 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Theorem</span> <a name="leb_refl"><span class="id" type="lemma">leb_refl</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#true"><span class="id" type="constructor">true</span></a> = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="zero_nbeq_S"><span class="id" type="lemma">zero_nbeq_S</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> 0 (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a>) = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#false"><span class="id" type="constructor">false</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="andb_false_r"><span class="id" type="lemma">andb_false_r</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">b</span> : <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#bool"><span class="id" type="inductive">bool</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#andb"><span class="id" type="definition">andb</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#false"><span class="id" type="constructor">false</span></a> = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#false"><span class="id" type="constructor">false</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_ble_compat_l"><span class="id" type="lemma">plus_ble_compat_l</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a> = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">→</span> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#leb"><span class="id" type="definition">leb</span></a> (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a>) (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a>) = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#true"><span class="id" type="constructor">true</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="S_nbeq_0"><span class="id" type="lemma">S_nbeq_0</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a>) 0 = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#false"><span class="id" type="constructor">false</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="mult_1_l"><span class="id" type="lemma">mult_1_l</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, 1 * <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="all3_spec"><span class="id" type="lemma">all3_spec</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">b</span> <span class="id" type="var">c</span> : <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#bool"><span class="id" type="inductive">bool</span></a>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#orb"><span class="id" type="definition">orb</span></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#andb"><span class="id" type="definition">andb</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#c"><span class="id" type="variable">c</span></a>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#orb"><span class="id" type="definition">orb</span></a> (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#b"><span class="id" type="variable">b</span></a>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#c"><span class="id" type="variable">c</span></a>))<br>
&nbsp;&nbsp;= <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#true"><span class="id" type="constructor">true</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="mult_plus_distr_r"><span class="id" type="lemma">mult_plus_distr_r</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;(<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a>) * <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a> = (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> * <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a>) + (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a> * <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a>).<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="mult_assoc"><span class="id" type="lemma">mult_assoc</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> * (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a> * <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a>) = (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> * <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a>) * <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
<div class="paragraph"> </div>

<a name="lab49"></a><h4 class="section">Exercise: 2 stars, optional (beq_nat_refl)</h4>
 Prove the following theorem.  (Putting the <span class="inlinecode"><span class="id" type="var">true</span></span> on the left-hand
    side of the equality may look odd, but this is how the theorem is
    stated in the Coq standard library, so we follow suit.  Rewriting
    works equally well in either direction, so we will have no problem
    using the theorem no matter which way we state it.) 
</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Theorem</span> <a name="beq_nat_refl"><span class="id" type="lemma">beq_nat_refl</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#true"><span class="id" type="constructor">true</span></a> = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
<div class="paragraph"> </div>

<a name="lab50"></a><h4 class="section">Exercise: 2 stars, optional (plus_swap')</h4>
 The <span class="inlinecode"><span class="id" type="tactic">replace</span></span> tactic allows you to specify a particular subterm to
   rewrite and what you want it rewritten to: <span class="inlinecode"><span class="id" type="tactic">replace</span></span> <span class="inlinecode">(<span class="id" type="var">t</span>)</span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode">(<span class="id" type="var">u</span>)</span>
   replaces (all copies of) expression <span class="inlinecode"><span class="id" type="var">t</span></span> in the goal by expression
   <span class="inlinecode"><span class="id" type="var">u</span></span>, and generates <span class="inlinecode"><span class="id" type="var">t</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">u</span></span> as an additional subgoal. This is often
   useful when a plain <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> acts on the wrong part of the goal.

<div class="paragraph"> </div>

   Use the <span class="inlinecode"><span class="id" type="tactic">replace</span></span> tactic to do a proof of <span class="inlinecode"><span class="id" type="var">plus_swap'</span></span>, just like
   <span class="inlinecode"><span class="id" type="var">plus_swap</span></span> but without needing <span class="inlinecode"><span class="id" type="tactic">assert</span></span> <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span>)</span>.

</div>
<div class="code code-tight">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_swap&#39;"><span class="id" type="lemma">plus_swap'</span></a> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a>) = <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#m"><span class="id" type="variable">m</span></a> + (<a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="http://www.seas.upenn.edu/~cis500/current/sf/Induction.html#p"><span class="id" type="variable">p</span></a>).<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
<div class="paragraph"> </div>

<a name="lab51"></a><h4 class="section">Exercise: 3 stars, recommended (binary_commute)</h4>
 Recall the <span class="inlinecode"><span class="id" type="var">increment</span></span> and <span class="inlinecode"><span class="id" type="var">binary</span>-<span class="id" type="var">to</span>-<span class="id" type="var">unary</span></span> functions that you
    wrote for the <span class="inlinecode"><span class="id" type="var">binary</span></span> exercise in the <span class="inlinecode"><span class="id" type="var">Basics</span></span> chapter.  Prove
    that the following diagram commutes:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">binnat</span>&nbsp;-------&nbsp;<span class="id" type="var">incr</span>&nbsp;------&gt;&nbsp;<span class="id" type="var">binnat</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bin2unary</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bin2unary</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">v</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">v</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">nat</span>&nbsp;----------&nbsp;<span class="id" type="var">S</span>&nbsp;---------&gt;&nbsp;<span class="id" type="var">nat</span>
<div class="paragraph"> </div>

</div>
    That is, incrementing a binary number and then converting it to 
    unary yields the same result as first converting it to unary 
    and then incrementing.  Name your theorem <span class="inlinecode"><span class="id" type="var">bin_to_nat_pres_incr</span></span>.

<div class="paragraph"> </div>

    Before you start working on this exercise, please copy the
    definitions from your solution to the <span class="inlinecode"><span class="id" type="var">binary</span></span> exercise here so
    that this file can be graded on its own.  If you find yourself
    wanting to change your original definitions to make the property
    easier to prove, feel free to do so! 
</div>
<div class="code code-tight">

<br>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br>
</div>

<div class="doc">
<font size="-2">☐</font> 
<div class="paragraph"> </div>

<a name="lab52"></a><h4 class="section">Exercise: 5 stars, advanced (binary_inverse)</h4>
 This exercise is a continuation of the previous exercise about
    binary numbers.  You will need your definitions and theorems from
    there to complete this one.

<div class="paragraph"> </div>

    (a) First, write a function to convert natural numbers to binary
        numbers.  Then prove that starting with any natural number,
        converting to binary, then converting back yields the same
        natural number you started with.

<div class="paragraph"> </div>

    (b) You might naturally think that we should also prove the
        opposite direction: that starting with a binary number,
        converting to a natural, and then back to binary yields the
        same number we started with.  However, this is not true!
        Explain what the problem is.

<div class="paragraph"> </div>

    (c) Define a "direct" normalization function — i.e., a function
        <span class="inlinecode"><span class="id" type="var">normalize</span></span> from binary numbers to binary numbers such that,
        for any binary number b, converting to a natural and then back
        to binary yields <span class="inlinecode">(<span class="id" type="var">normalize</span></span> <span class="inlinecode"><span class="id" type="var">b</span>)</span>.  Prove it.  (Warning: This
        part is tricky!)

<div class="paragraph"> </div>

    Again, feel free to change your earlier definitions if this helps
    here.

</div>
<div class="code code-tight">

<br>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code code-tight">

<br>
</div>

<div class="doc">
<a name="lab53"></a><h1 class="section">Formal vs. Informal Proof (Optional)</h1>

<div class="paragraph"> </div>

 <div class="quote proofs are algorithms; formal proofs are code." &lt;="" div&gt;="" *)="" (**="" the="" question="" of="" what="" constitutes="" a="" proof="" mathematical="" claim="" has="" challenged="" philosophers="" for="" millennia,="" but="" rough="" and="" ready="" definition="" could="" be="" this:="" proposition="" [p]="" is="" written="" (or="" spoken)="" text="" that="" instills="" in="" reader="" or="" hearer="" certainty="" true.="" is,="" an="" act="" communication.="" acts="" communication="" may="" involve="" different="" sorts="" readers.="" on="" one="" hand,="" "reader"="" can="" program="" like="" coq,="" which="" case="" "belief"="" instilled="" mechanically="" derived="" from="" certain="" set="" formal="" logical="" rules,="" recipe="" guides="" checking="" this="" fact.="" such="" recipes="" are="" _formal_="" proofs.="" alternatively,="" human="" being,="" will="" english="" some="" other="" natural="" language,="" thus="" necessarily="" _informal_.="" here,="" criteria="" success="" less="" clearly="" specified.="" "valid"="" makes="" believe="" [p].="" same="" read="" by="" many="" readers,="" whom="" convinced="" particular="" way="" phrasing="" argument,="" while="" others="" not="" be.="" readers="" particularly="" pedantic,="" inexperienced,="" just="" plain="" thick-headed;="" only="" to="" convince="" them="" make="" argument="" painstaking="" detail.="" more="" familiar="" area,="" find="" all="" detail="" so="" overwhelming="" they="" lose="" overall="" thread;="" want="" told="" main="" ideas,="" since="" it="" easier="" fill="" details="" themselves="" than="" wade="" through="" presentation="" them.="" ultimately,="" there="" no="" universal="" standard,="" because="" single="" writing="" informal="" guaranteed="" every="" conceivable="" reader.="" practice,="" however,="" mathematicians="" have="" developed="" rich="" conventions="" idioms="" about="" complex="" objects="" --="" at="" least="" within="" community="" fairly="" reliable.="" stylized="" form="" give="" clear="" standard="" judging="" proofs="" good="" bad.="" we="" using="" coq="" course,="" working="" heavily="" with="" doesn't="" mean="" completely="" forget="" ones!="" useful="" ways,="" _not_="" very="" efficient="" ways="" communicating="" ideas="" between="" beings.="" example,="" here="" addition="" associative:="" theorem="" plus_assoc'="" :="" forall="" n="" m="" p="" nat,="" +="" (m="" p)="(n" m)="" p.="" proof.="" intros="" induction="" as="" [|="" n'="" ihn'].="" reflexivity.="" simpl.="" rewrite="" -=""> IHn'. reflexivity.  Qed.

(** Coq is perfectly happy with this.  For a human, however, it
    is difficult to make much sense of it.  We can use comments and
    bullets to show the structure a little more clearly... *)

Theorem plus_assoc'' : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
  intros n m p. induction n as [| n' IHn'].
  - (* n = 0 *)
    reflexivity.
  - (* n = S n' *)
    simpl. rewrite -&gt; IHn'. reflexivity.   Qed.

(** ... and if you're used to Coq you may be able to step
    through the tactics one after the other in your mind and imagine
    the state of the context and goal stack at each point, but if the
    proof were even a little bit more complicated this would be next
    to impossible.

    A (pedantic) mathematician might write the proof something like
    this: *)
(** - _Theorem_: For any [n], [m] and [p],
[[
      n + (m + p) = (n + m) + p.
]]
    _Proof_: By induction on [n].

    - First, suppose [n = 0].  We must show
[[
        0 + (m + p) = (0 + m) + p.
]]
      This follows directly from the definition of [+].

    - Next, suppose [n = S n'], where
[[
        n' + (m + p) = (n' + m) + p.
]]
      We must show
[[
        (S n') + (m + p) = ((S n') + m) + p.
]]
      By the definition of [+], this follows from
[[
        S (n' + (m + p)) = S ((n' + m) + p),
]]
      which is immediate from the induction hypothesis.  _Qed_. *)


(** The overall form of the proof is basically similar, and of
    course this is no accident: Coq has been designed so that its
    [induction] tactic generates the same sub-goals, in the same
    order, as the bullet points that a mathematician would write.  But
    there are significant differences of detail: the formal proof is
    much more explicit in some ways (e.g., the use of [reflexivity])
    but much less explicit in others (in particular, the "proof state"
    at any given point in the Coq proof is completely implicit,
    whereas the informal proof reminds the reader several times where
    things stand). *)

(** **** Exercise: 2 stars, advanced, recommended (plus_comm_informal)  *)
(** Translate your solution for [plus_comm] into an informal proof. *)

(** Theorem: Addition is commutative.

    Proof: (* FILL IN HERE *)
*)
(** [] *)


(** **** Exercise: 2 stars, optional (beq_nat_refl_informal)  *)
(** Write an informal proof of the following theorem, using the
    informal proof of [plus_assoc] as a model.  Don't just
    paraphrase the Coq tactics into English!

    Theorem: [true = beq_nat n n] for any [n].

    Proof: (* FILL IN HERE *)
[] *)

(** $Date: 2016-02-17 17:39:13 -0500 (Wed, 17 Feb 2016) $ *)

</div>
<div class="code code-tight">
</div>
</div>

<div id="footer">
<hr><a href="http://www.seas.upenn.edu/~cis500/current/sf/coqindex.html">Index</a></div>

</div>


</div><audio controls="controls" style="display: none;"></audio></body><style type="text/css">#yddContainer{display:block;font-family:Microsoft YaHei;position:relative;width:100%;height:100%;top:-4px;left:-4px;font-size:12px;border:1px solid}#yddTop{display:block;height:22px}#yddTopBorderlr{display:block;position:static;height:17px;padding:2px 28px;line-height:17px;font-size:12px;color:#5079bb;font-weight:bold;border-style:none solid;border-width:1px}#yddTopBorderlr .ydd-sp{position:absolute;top:2px;height:0;overflow:hidden}.ydd-icon{left:5px;width:17px;padding:0px 0px 0px 0px;padding-top:17px;background-position:-16px -44px}.ydd-close{right:5px;width:16px;padding-top:16px;background-position:left -44px}#yddKeyTitle{float:left;text-decoration:none}#yddMiddle{display:block;margin-bottom:10px}.ydd-tabs{display:block;margin:5px 0;padding:0 5px;height:18px;border-bottom:1px solid}.ydd-tab{display:block;float:left;height:18px;margin:0 5px -1px 0;padding:0 4px;line-height:18px;border:1px solid;border-bottom:none}.ydd-trans-container{display:block;line-height:160%}.ydd-trans-container a{text-decoration:none;}#yddBottom{position:absolute;bottom:0;left:0;width:100%;height:22px;line-height:22px;overflow:hidden;background-position:left -22px}.ydd-padding010{padding:0 10px}#yddWrapper{color:#252525;z-index:10001;background:url(chrome-extension://eopjamdnofihpioajgfdikhhbobonhbb/ab20.png);}#yddContainer{background:#fff;border-color:#4b7598}#yddTopBorderlr{border-color:#f0f8fc}#yddWrapper .ydd-sp{background-image:url(chrome-extension://eopjamdnofihpioajgfdikhhbobonhbb/ydd-sprite.png)}#yddWrapper a,#yddWrapper a:hover,#yddWrapper a:visited{color:#50799b}#yddWrapper .ydd-tabs{color:#959595}.ydd-tabs,.ydd-tab{background:#fff;border-color:#d5e7f3}#yddBottom{color:#363636}#yddWrapper{min-width:250px;max-width:400px;}</style></html>