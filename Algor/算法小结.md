# 算法小结

标签（空格分隔）： 未分类

---
1.逆转链表
2.栈，和队列。栈（递归也是隐式栈）
3.模式匹配，KMP
4.树，深度搜索，DFS,哈夫曼算法
5.图算法
1）最小生成树
2）拓扑排序（当有向图无环时,DFS）
6.搜索和查找
1）二叉排序树和平衡二叉树
2）哈希表
7.排序
1）堆排序
2）快排
3）插入排序
4）归并排序
7.中位数排序
8.红黑树
9.回溯算法:
深度搜索+剪枝
1）八皇后
2）迷宫问题
10.动态规划算法
1）最长公共子序列（注意不是连续的，否则就是模式匹配）
2）最长递增子序列
3）金砖问题，这个问题也可以用回溯去解决
11.谈心问题，也就是金粉问题

----------------------------

#启发式搜索：
定义：首先有状态空间，这个所有各种解就构成状态空间。然后状态空间搜索有深度优先和广度优先两种。但是，这两种都是杂给定空间中进行搜索，当空间非常大时，效率就比较低。启发式就是对对每一个搜索的位置进行评估，得到最好的位置，然后再冲这个位置出发找到目标。启发式搜索算法有点像广度优先搜索，不同的是，它会优先顺着有启发性和具有特定信息的节点搜索下去，这些节点可能是到达目标的最好路径。



。代表算法有：遗传算法，模拟退火算法。


1.退火算法：属于一种蒙特卡洛的迭代求解法的一种启发式随机搜索过程。
模拟退火算法可以分解为解空间、目标函数和初始解三部分。

介绍模拟退火前，先介绍爬山算法。爬山算法是一种简单的贪心搜索算法，该算法每次从当前解的临近解空间中选择一个最优解作为当前解，直到达到一个局部最优解。

模拟退火算法是一种随机算法，并不一定能找到全局的最优解，可以比较快的找到问题的近似最优解。如果参数设置得当，模拟退火算法搜索效率比穷举法要高。

爬山法是完完全全的贪心法，每次都鼠目寸光的选择一个当前最优解，因此只能搜索到局部的最优值。模拟退火其实也是一种贪心算法，但是它的搜索过程引入了随机因素。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。以图1为例，模拟退火算法在搜索到局部最优解A后，会以一定的概率接受到E的移动。也许经过几次这样的不是局部最优的移动后会到达D点，于是就跳出了局部最大值A。

模拟退火算法描述：
若J( Y(i+1) )>= J( Y(i) )  (即移动后得到更优解)，则总是接受该移动

若J( Y(i+1) )< J( Y(i) )  (即移动后的解比当前解要差)，则以一定的概率接受移动，而且这个概率随着时间推移逐渐降低（逐渐降低才能趋向稳定）

这个算法可以用来解决旅行商问题。
使用模拟退火算法可以比较快的求出TSP的一条近似最优路径。（使用遗传算法也是可以的，我将在下一篇文章中介绍）模拟退火解决TSP的思路：

1. 产生一条新的遍历路径P(i+1)，计算路径P(i+1)的长度L( P(i+1) )

2. 若L(P(i+1)) < L(P(i))，则接受P(i+1)为新的路径，否则以模拟退火的那个概率接受P(i+1) ，然后降温

3. 重复步骤1，2直到满足退出条件产生新的遍历路径的方法有很多，下面列举其中3种：

1）. 随机选择2个节点，交换路径中的这2个节点的顺序。

2）. 随机选择2个节点，将路径中这2个节点间的节点顺序逆转。

3）. 随机选择3个节点m，n，k，然后将节点m与n间的节点移位到节点k后面。

2.遗传算法：
简单说来就是：繁殖过程，会发生基因交叉( Crossover ) ，基因突变 ( Mutation ) ，适应度( Fitness )低的个体会被逐步淘汰，而适应度高的个体会越来越多。那么经过N代的自然选择后，保存下来的个体都是适应度很高的，其中很可能包含史上产生的适应度最高的那个个体。

简单地说这个算法思想就是：
借鉴生物进化论，遗传算法将要解决的问题模拟成一个生物进化的过程，通过复制、交叉、突变等操作产生下一代的解，并逐步淘汰掉适应度函数值低的解，增加适应度函数值高的解。这样进化N代后就很有可能会进化出适应度函数值很高的个体。

举个例子，使用遗传算法解决“0-1背包问题”的思路：0-1背包的解可以编码为一串0-1字符串（0：不取，1：取） ；首先，随机产生M个0-1字符串，然后评价这些0-1字符串作为0-1背包问题的解的优劣；然后，随机选择一些字符串通过交叉、突变等操作产生下一代的M个字符串，而且较优的解被选中的概率要比较高。这样经过G代的进化后就可能会产生出0-1背包问题的一个“近似最优解”。

遗传算法有3个最基本的操作：选择，交叉，变异。

3.一个通用的图搜索算法
这个算法可用来执行最优搜索、广度优先搜索或深度优先搜索。
在广度优先搜索中，新节点只要放在OPEN的尾部即可（先进先出， FIFO），节点不用重排。
在深度优先搜索中，新节点放在OPEN的开始（后进先出,LIFO）。
在最优（也叫启发式）搜索中，按照节点的启发式方式来重排OPEN。

在算法A*中，我们用ˆf(n)= gˆ(n)+ hˆ(n)。

通过上图，我们可以看出：：A*算法最为核心的过程，就在每次选择下一个当前搜索点时，是从所有已探知的但未搜索过点中(可能是不同层，亦可不在同一条支路上)，选取f值最小的结点进行展开。
      而所有“已探知的但未搜索过点”可以通过一个按f值升序的队列(即优先队列)进行排列。
      这样，在整体的搜索过程中，只要按照类似广度优先的算法框架，从优先队列中弹出队首元素（f值），对其可能子结点计算g、h和f值，直到优先队列为空(无解)或找到终止点为止。

A*算法与广度、深度优先和Dijkstra算法的联系就在于：当g(n)=0时，该算法类似于DFS，当h(n)=0时，该算法类似于BFS。且同时，如果h(n)为0，只需求出g(n)，即求出起点到任意顶点n的最短路径，则转化为单源最短路径问题，即Dijkstra算法。这一点，可以通过上面的A*搜索树的具体过程中将h(n)设为0或将g(n)设为0而得到。 

总结：

首先将起始结点S放入OPEN表，CLOSE表置空，算法开始时：
1、如果OPEN表不为空，从表头取一个结点n，如果为空算法失败。
2、n是目标解吗？是，找到一个解（继续寻找，或终止算法）。
3、将n的所有后继结点展开，就是从n可以直接关联的结点（子结点），如果不在CLOSE表中，就将它们放入OPEN表，并把S放入CLOSE表，同时计算每一个后继结点的估价值f(n)，将OPEN表按f(x)排序，最小的放在表头，重复算法，回到1。

4.集束算法：beam search:
束搜索(beam search)方法是解决优化问题的一种启发式方法，它是在分枝定界方法基础上发展起来的，它使用启发式方法估计k个最好的路径，仅从这k个路径出发向下搜索，即每一层只有满意的结点会被保留，其它的结点则被永久抛弃，从而比分枝定界法能大大节省运行时间。

5.分枝定界算法：Branch and bound
分支定界(branch and bound)算法是一种在问题的解空间树上搜索问题的解的方法。但与回溯算法不同，分支定界算法采用广度优先或最小耗费优先的方法搜索解空间树，并且，在分支定界算法中，每一个活结点只有一次机会成为扩展结点，就是广度优先算法。

--------------------------------------------

PS：
1.如何把递归改写成栈程序
进制转换



