# 动态规划

标签（空格分隔）： 未分类

---

动态规划是要求：有个最小的子问题结构，可以递归地解决。然后建立一个状态转移方程。
所以要求两方面：
1）一是定义一个状态
2）建立一个状态转移方程
比较基本而且经典的问题有：
1.最长递增子序列
2.最长公共子序列
3.背包问题（0-1背包，完全背包，多重背包）

###一维的动态规划问题
1.假如现在有1，3，5元硬币，求用最少的硬币凑成13元。
这个是个典型的动态规划问题。
这样思考：假如0元呢，那么最少就是0元，1元呢，最少是1个，2元呢最少是2个。3元呢，最少是1个。
那么我们来定义一个数组，dp[i]:表示i元最少需要几个硬币.
```
int dap(int n) {
  int MIN;
  int i,j;

  dp[0] = 0;
  for(i = 1;i <= n;i++) {
    if(i != 1 && i != 3 && i != 5) {
     // 这是状态转移方程，最小值肯定是这个求出来的
      MIN = dp[i-1] + 1;
      for(j = 1;j < i; j++)
	     MIN = min((dp[i-j]+dp[j]),MIN);
      dp[i] = MIN;
      
    } else
      dp[i] = 1;
  }
  return dp[n];
}
```

2.对于最长递增自序列
longest incresing sequence:lis
我们也可以用动态规划。
1）定义一个状态dp[i]:表示在以i为结尾的的字符序列中，最长为的dp[i].
2）状态转移方程：dp[i] = max(dp[j] +1),1) (A[i] > a[j])

```
for(i = 0;i < len ;i++) {
    temp = 1;
    for(j = 0;j < i;j ++)
      if(input[i] >= input[j]) {
	    temp = max(temp,dp[j] + 1);
      }
    dp[i] = temp;
}
```
改算法的时间复杂度为：O(n^2 )，并不是最优的解法，但是解法很简单。

###二维的动态规划问题
假设有这样一个问题：
平面上有N*M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始， 每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来， 这样下去，你最多能收集到多少个苹果。

解这个问题与解其它的DP问题几乎没有什么两样。第一步找到问题的“状态”， 第二步找到“状态转移方程”，然后基本上问题就解决了。
```
int maze() {
  int i,j;

  dp[0][0] = input[0][0];
  for(i = 1; i < m;i++)
    dp[0][i] = input[0][i]+dp[0][i-1];

  for(i = 1; i < n;i++)
    dp[i][0] = input[i][0] + dp[i-1][0];

  for(i = 1;i < n;i++)
    for(j = 1;j < m;j++)
      dp[i][j] = max(dp[i-1][j],dp[i][j-1]) + input[i][j];

}
```

dp[i][j]有两种计算方式：1.对于每一行，从左向右计算，然后从上到下逐行处理；2.对于每一列，从上到下计算，然后从左向右逐列处理。 
这样做的目的是为了在计算dp[i][j]时，dp[i-1][j]和dp[i][j-1]都已经计算出来了。

###其它例子。
1)很典型的例子有lcs问题
最长共同自序列
下面来说明如下：
```
//dp[i][j]:表示s1的前i个字符和s2的前j个字符中最多有多少相同的
int dp[100][100];

int lcs(string& s1,string& s2) {
  int len1,len2;

  len1 = s1.length();
  len2 = s2.length();

  for(int i=0;i < len1;i++)
    dp[i][0] = 0;

  for(int j=0;j < len2;j++)
    dp[0][j] = 0;


  for(int i=0;i < len1;i++)
    for(int j=0;j < len2;j++) {
      if(s1[i] == s2[j])
	dp[i][j] = dp[i-1][j-1] +1;
      else 
	dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
    }

  return dp[len1-1][len2-1];
}
```
2）0-1背包问题，这是个典型的动态规划问题
```

		
//the nth food v max = 0  
for (i = 0; i <= w; i++)
    dp[0][i] = 0;

for (i = 1; i<= n; i++) {
    //1) j big than the nth packet
    for (j = w; j >= list[i].w ;j--)
        dp[i][j] = max(dp[i-1][j-list[i].w]+list[i].v,dp[i-1][j]);
    
    //2) because it can;t put in ,so equal the last
    for (j = list[i].w - 1; j>=0 ;j--)
	    dp[i][j] = dp[i-1][j];
}

```
注意这里第二个循环是逆序，这里是正序也无所谓的。之所以是逆许，是因为便于改成一维数组的，所以就写成了一维数组。

其实这个代码的空间可以优化，我们可以改成如下这样。
因为我们发现dp[i][j]的转移仅仅与上一行有关,且从左到右计算所需要的信息都位于左方。所以，我们可以把二维数组转化为一组。
比如状态转移就可以变为
```
dp[j] = max(dp[j-list[i].w]+list[i].v ,dp[j]);
```
真正的代码如下:

```
for (i = 0; i <= w; i++)
    dp[i] = 0;
    
for (i = 1; i<= n; i++) {
  for (j = w; j >= list[i].w ;j--)
       dp[j] = max(dp[j-list[i].w]+list[i].v,dp[j])
```
这里是逆序列，是因为我要求出根据上一行，那些没有放进去的那些数据。

**变化**：有的时候可能有点变化，就是0-1背包变成体积刚好体积是W的的0-1背包，状态转移完全一样，唯一的就是初始化为dp[0][0] = 0;dp[o][j] = 负无穷或者用0x80000000最大的负数来表示。
```
dp[0][0] = 0
for (i = 1; i <= w; i++)
    dp[i] = -1;
    
for (i = 1; i<= n; i++) {
  for (j = w; j >= list[i].w ;j--)
    if(dp[j-list[i].w] != -1) {
       dp[j] = max(dp[j-list[i].w]+list[i].v,dp[j])
     }
```

3）完全背包问题
就是每个物品的数量均为无限多个。同样可以简化为0-1背包，假设每个物品被均分，则一共可以分为V/vi个，这样就变成n个同样的物品。不过这个解的复杂度会比较复杂，不过这个思想可以利用，这是个很好的思想。

```
//这个n就是表示物品的种类而不是整个数量了
for (i = 1; i<= n; i++) {
  for (j = list[i].w;j <= w;j++)
       dp[j] = max(dp[j-list[i].w]+list[i].v,dp[j])
```
和0-1背包区别的就是顺序反了，0-1是逆序，这里是顺序。这里是正序列，是因为这个物品有可能被放进去多次。注意我们不可以改成这样，下面这个写法是不对的。
```
for (i = 1; i<= n; i++) {
  for (j = list[i].w;j <= w;j++)
       dp[i][j] = max(dp[i-1][j-list[i].w]+list[i].v,dp[i-1][j])
```
因为可以放进去多次，所以dp[i][j]可能有这个转移而来dp[i][[j-list[i].w]

4)多重背包问题：
同样，我们可以根据完全背包问题的化解，我们也可以优化这样去做。同样的把物品拆分为无数个同样的物品，不过这个本身就是有限个同样的物品的。不过，我们分组去进行拆分，这样的话，我们拆分就变成，：1，2，4，8这样在物品上去进行拆分，然后。在进行普通的0-1背包运算。这样，解决了多重背包的问题,还是分解这个思想。


PS：这里的完全背包我是划组了，这样就相当于是不同的物品，当然也可以不划组，直接算，每个物品可以选进去N次，不过这种复杂度比较高，因为有三重循环。下面是划分N个，不分组的完全背包和多重背包。
```
//完全背包
dp[i][v] = max{dp[i-1][v - k * c[i]] + k * w[i] | 0 <= k * c[i]<= v} 

//多重背包
dp[i][v] = max{dp[i - 1][v - k * c[i]] + w[i] | 0 <=k <= n[i]}  

//多重背包代码
for (i = 1; i <= m; i ++) {  
        for (j = 1; j <= n; j ++) {  
            for (k = 0; k <= rices[i].num; k ++) {  
                if (j - k * rices[i].price >= 0) {  
                    cur = dp[i - 1][j - k * rices[i].price] + k * rices[i].weight;  
                    dp[i][j] = dp[i][j] > cur ? dp[i][j] : cur;  
                } else {  
                    break;  
                }  
            }  
        }  
} 
```
不过，不推荐上面这个思路。还是在物品时，直接划为组比较好。时间复杂度要低一点。

###带有额外条件的DP问题
#总结当阅读一个题目并且开始尝试解决它时，首先看一下它的限制。 如果要求在多项式时间内解决，那么该问题就很可能要用DP来解。遇到这种情况， 最重要的就是找到问题的“状态”和“状态转移方程”。(状态不是随便定义的， 一般定义完状态，你要找到当前状态是如何从前面的状态得到的， 即找到状态转移方程)如果看起来是个DP问题，但你却无法定义出状态， 那么试着将问题规约到一个已知的DP问题(正如“高级”一节中的例子一样)。