# 关于二分查找

标签（空格分隔）： 未分类

---
1.关于二分查找

```
while (low <= high) {
    int mid = low + (high-low)/2;
    if (a[mid] > key)
        high = mid-1;
    else if (a[mid] < key)
        low = mid+1;
    else
        return mid;
}
```

2.有几点需要注意下：
1）如果不会死直接比较a[mid]出来的，那么肯定是这样的。
先是比较low，然后比较high。
比如low=3,high=4,先是比较(3+4)/2,比较3,再接着比较4.

2）最后结束循环肯定是low = high +1.

3）如果有重复数字，找到最下的那个和最上的那个，其实是有技巧的。
```
  int binserchxia(vector<int>& nums,int target) {
    int low,high,mid;

    low = 0;
    high = nums.size() - 1;

    while (low <= high) {
      mid = low + (high -low) / 2;

      if (nums[mid] < target)
 	    low = mid + 1;
      else
  	     high = mid - 1;
    }
    if (nums[low] == target)
      return low;
    return - 1;
  }

  
  int binserchsha(vector<int>& nums,int target) {
    int low,high,mid;

    low = 0;
    high = nums.size() - 1;

    while (low <= high) {
      mid = low + (high -low) / 2;

      if (nums[mid] >  target)
	    high = mid - 1;
      else
	    low = mid + 1;
    }
    if (nums[high] == target)
      return high;
    return - 1;
  }
  
```



